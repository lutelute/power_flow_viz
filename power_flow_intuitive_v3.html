<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ½®æµè¨ˆç®— åæŸå¯è¦–åŒ– - ç›´æ„Ÿçš„ç†è§£</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f0f1a;
            --bg-card: #1a1a2e;
            --bg-surface: #252540;
            --accent-blue: #4dabf7;
            --accent-green: #51cf66;
            --accent-orange: #ffa94d;
            --accent-red: #ff6b6b;
            --accent-purple: #cc5de8;
            --accent-cyan: #22b8cf;
            --text-primary: #e9ecef;
            --text-secondary: #868e96;
            --border: #3d3d5c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0 30px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 25px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        /* Control Panel */
        .control-panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        select, input[type="range"] {
            background: var(--bg-surface);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        select:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        input[type="range"] {
            width: 120px;
            padding: 0;
            height: 6px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
            color: var(--bg-dark);
        }

        .btn-secondary {
            background: var(--bg-surface);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .viz-card {
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
        }

        .viz-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .viz-title {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .viz-title .icon {
            font-size: 1.2rem;
        }

        .viz-body {
            padding: 15px;
            height: 400px;
            position: relative;
        }

        .viz-body canvas {
            width: 100%;
            height: 100%;
        }

        /* Info Panel */
        .info-panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-stat {
            background: var(--bg-surface);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .info-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-cyan);
        }

        .info-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        /* Explanation Panel */
        .explanation {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
        }

        .explanation h3 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: var(--accent-cyan);
        }

        .explanation-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .explanation-item {
            background: var(--bg-surface);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-purple);
        }

        .explanation-item h4 {
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--accent-orange);
        }

        .explanation-item p {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Algorithm steps */
        .algo-steps {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .algo-step {
            padding: 6px 12px;
            background: var(--bg-surface);
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            border: 1px solid transparent;
        }

        .algo-step.active {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(34, 184, 207, 0.1);
        }

        .algo-step.done {
            color: var(--accent-green);
            border-color: var(--accent-green);
        }

        /* Equation display */
        .equation-box {
            background: var(--bg-surface);
            border-radius: 8px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.8;
            overflow-x: auto;
        }

        .eq-var { color: var(--accent-orange); }
        .eq-num { color: var(--accent-green); }
        .eq-op { color: var(--accent-purple); }
        .eq-highlight { 
            background: rgba(34, 184, 207, 0.2); 
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Trajectory info */
        .trajectory-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(26, 26, 46, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Navigation Bar */
        .nav-bar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 8px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--text-primary);
        }

        .nav-logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .nav-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .nav-links {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: var(--bg-surface);
            color: var(--accent-cyan);
        }

        .nav-link.primary {
            background: var(--accent-cyan);
            color: var(--bg-dark);
            font-weight: 500;
        }

        .nav-link.primary:hover {
            background: var(--accent-green);
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="nav-bar">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">
                <div class="nav-logo-icon">âš¡</div>
                <span class="nav-title">Power Flow Visualization</span>
            </a>
            <div class="nav-links">
                <a href="index.html" class="nav-link primary">ğŸ  ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</a>
                <a href="https://github.com/lutelute/power_flow_viz" class="nav-link" target="_blank">ğŸ“ GitHub</a>
            </div>
        </div>
    </nav>
    <div class="container">
        <header>
            <h1>âš¡ æ½®æµè¨ˆç®— åæŸã®å¯è¦–åŒ–</h1>
            <p class="subtitle">è§£ã«å‘ã‹ã£ã¦åæŸã—ã¦ã„ãæ§˜å­ã‚’ç›´æ„Ÿçš„ã«ç†è§£ã™ã‚‹</p>
        </header>

        <div class="control-panel">
            <div class="control-group">
                <label>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ :</label>
                <select id="algoSelect">
                    <option value="newton">Newton-Raphsonæ³•</option>
                    <option value="gauss-seidel">Gauss-Seidelæ³•</option>
                    <option value="gradient">å‹¾é…é™ä¸‹æ³•</option>
                </select>
            </div>
            <div class="control-group">
                <label>å•é¡Œ:</label>
                <select id="problemSelect">
                    <option value="2bus">2ãƒãƒ¼ãƒ‰ç³»çµ±ï¼ˆå°è¦æ¨¡ï¼‰</option>
                    <option value="2bus_hard">2ãƒãƒ¼ãƒ‰ç³»çµ±ï¼ˆå›°é›£ï¼‰</option>
                    <option value="ieee5">IEEE 5ãƒãƒ¼ãƒ‰ç³»çµ±ï¼ˆä¸­è¦æ¨¡ï¼‰</option>
                    <option value="voltage">é›»åœ§å®‰å®šæ€§å•é¡Œ</option>
                </select>
            </div>
            <div class="control-group">
                <label>é€Ÿåº¦:</label>
                <input type="range" id="speedSlider" min="0.2" max="3" step="0.1" value="1">
                <span id="speedValue">1.0x</span>
            </div>
            <div class="control-group">
                <button class="btn btn-primary" id="runBtn">â–¶ å®Ÿè¡Œ</button>
                <button class="btn btn-secondary" id="stepBtn">â­ 1ã‚¹ãƒ†ãƒƒãƒ—</button>
                <button class="btn btn-secondary" id="resetBtn">â†º ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-grid">
                <div class="info-stat">
                    <div class="info-value" id="iterValue">0</div>
                    <div class="info-label">åå¾©å›æ•°</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="errorValue">-</div>
                    <div class="info-label">èª¤å·® ||f(x)||</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="voltageValue">-</div>
                    <div class="info-label">é›»åœ§ |Vâ‚‚|</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="angleValue">-</div>
                    <div class="info-label">ä½ç›¸è§’ Î´â‚‚</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="statusValue">å¾…æ©Ÿä¸­</div>
                    <div class="info-label">çŠ¶æ…‹</div>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <!-- Complex Voltage Plane -->
            <div class="viz-card">
                <div class="viz-header">
                    <div class="viz-title">
                        <span class="icon">ğŸ“</span>
                        è¤‡ç´ é›»åœ§å¹³é¢
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: var(--accent-cyan);"></div>
                            <span>ç¾åœ¨ä½ç½®</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: var(--accent-green);"></div>
                            <span>è§£ï¼ˆç›®æ¨™ï¼‰</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: var(--accent-orange);"></div>
                            <span>è»Œè·¡</span>
                        </div>
                    </div>
                </div>
                <div class="viz-body">
                    <canvas id="complexPlane"></canvas>
                    <div class="trajectory-info" id="trajectoryInfo">
                        V = 1.00âˆ 0Â°
                    </div>
                </div>
            </div>

            <!-- Error Surface -->
            <div class="viz-card">
                <div class="viz-header">
                    <div class="viz-title">
                        <span class="icon">ğŸ”ï¸</span>
                        èª¤å·®æ›²é¢ï¼ˆè°·åº•ãŒè§£ï¼‰
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-dot" style="background: var(--accent-red);"></div>
                            <span>ç¾åœ¨ä½ç½®</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background: white;"></div>
                            <span>æ¢ç´¢çµŒè·¯</span>
                        </div>
                    </div>
                </div>
                <div class="viz-body">
                    <canvas id="errorSurface"></canvas>
                </div>
            </div>

            <!-- Mismatch Vector Field -->
            <div class="viz-card">
                <div class="viz-header">
                    <div class="viz-title">
                        <span class="icon">ğŸ§­</span>
                        ãƒŸã‚¹ãƒãƒƒãƒãƒ™ã‚¯ãƒˆãƒ«å ´
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <span>çŸ¢å° = è§£ã¸ã®æ–¹å‘</span>
                        </div>
                    </div>
                </div>
                <div class="viz-body">
                    <canvas id="vectorField"></canvas>
                </div>
            </div>

            <!-- Convergence History -->
            <div class="viz-card">
                <div class="viz-header">
                    <div class="viz-title">
                        <span class="icon">ğŸ“ˆ</span>
                        åæŸå±¥æ­´
                    </div>
                    <div class="algo-steps" id="algoSteps">
                        <div class="algo-step" data-step="0">åˆæœŸåŒ–</div>
                        <div class="algo-step" data-step="1">èª¤å·®è¨ˆç®—</div>
                        <div class="algo-step" data-step="2">æ›´æ–°æ–¹å‘</div>
                        <div class="algo-step" data-step="3">çŠ¶æ…‹æ›´æ–°</div>
                        <div class="algo-step" data-step="4">åæŸåˆ¤å®š</div>
                    </div>
                </div>
                <div class="viz-body">
                    <canvas id="convergenceChart"></canvas>
                </div>
            </div>
        </div>

        <div class="explanation">
            <h3>ğŸ’¡ ä½•ãŒèµ·ãã¦ã„ã‚‹ã‹ï¼Ÿ</h3>
            <div class="explanation-content">
                <div class="explanation-item">
                    <h4>è¤‡ç´ é›»åœ§å¹³é¢</h4>
                    <p>é›»åœ§ã‚’è¤‡ç´ æ•° V = |V|e^(jÎ´) ã§è¡¨ç¾ã€‚åˆæœŸå€¤ï¼ˆé€šå¸¸ 1.0âˆ 0Â°ï¼‰ã‹ã‚‰ã€çœŸã®è§£ã«å‘ã‹ã£ã¦ç‚¹ãŒç§»å‹•ã—ã¦ã„ãã¾ã™ã€‚</p>
                </div>
                <div class="explanation-item">
                    <h4>èª¤å·®æ›²é¢</h4>
                    <p>||Î”P||Â² + ||Î”Q||Â² ã®å€¤ã‚’é«˜ã•ã§è¡¨ç¾ã€‚è§£ã¯è°·åº•ã«ã‚ã‚Šã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯å±±ã‚’ä¸‹ã£ã¦ã„ãã¾ã™ã€‚Newtonæ³•ã¯æ€¥é™ä¸‹ã€Gauss-Seidelã¯ã‚¸ã‚°ã‚¶ã‚°ã«é™ã‚Šã¾ã™ã€‚</p>
                </div>
                <div class="explanation-item">
                    <h4>ãƒ™ã‚¯ãƒˆãƒ«å ´</h4>
                    <p>å„ç‚¹ã§ã®ã€ŒåŠ›ã€ã®å‘ãã€‚ãƒŸã‚¹ãƒãƒƒãƒï¼ˆÎ”P, Î”Qï¼‰ãŒä½œã‚‹å ´ã§ã€çŸ¢å°ã¯è§£ã«å‘ã‹ã†æ–¹å‘ã‚’ç¤ºã—ã¾ã™ã€‚è§£ã®å‘¨ã‚Šã§ã¯çŸ¢å°ãŒåæŸã—ã¾ã™ã€‚</p>
                </div>
                <div class="explanation-item">
                    <h4>åæŸé€Ÿåº¦ã®é•ã„</h4>
                    <p>Newtonæ³•: 2æ¬¡åæŸï¼ˆèª¤å·®ãŒæ¯å›2ä¹—ã«æ¸›å°‘ï¼‰<br>
                    Gauss-Seidel: 1æ¬¡åæŸï¼ˆç·šå½¢ã«æ¸›å°‘ï¼‰<br>
                    å‹¾é…é™ä¸‹: ã‚¹ãƒ†ãƒƒãƒ—å¹…ä¾å­˜</p>
                </div>
            </div>
        </div>

        <div class="explanation" style="margin-top: 20px;">
            <h3>ğŸ“ ç¾åœ¨ã®è¨ˆç®—å¼</h3>
            <div class="equation-box" id="equationBox">
                å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨è¨ˆç®—éç¨‹ãŒè¡¨ç¤ºã•ã‚Œã¾ã™
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // Problem Definitions
        // ============================================================
        const problems = {
            '2bus': {
                name: '2ãƒãƒ¼ãƒ‰ç³»çµ± (å°è¦æ¨¡)',
                description: 'æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªä¾‹ï¼šç™ºé›»æ©Ÿ(Slack)ã¨è² è·(PQ)',
                // Bus 1: Slack (V=1.0, Î´=0)
                // Bus 2: PQ (P=-0.5, Q=-0.2)
                Ybus: [
                    [{ re: 10, im: -30 }, { re: -10, im: 30 }],
                    [{ re: -10, im: 30 }, { re: 10, im: -30 }]
                ],
                buses: [
                    { type: 'Slack', V: 1.0, delta: 0, P: 0, Q: 0 },
                    { type: 'PQ', V: 1.0, delta: 0, Pspec: -0.5, Qspec: -0.2 }
                ],
                solution: { V: 0.9487, delta: -0.0927 }, // Correctly calculated
                initialPoint: { V: 1.2, delta: 0.2 } // Far from solution
            },
            '2bus_hard': {
                name: '2ãƒãƒ¼ãƒ‰ç³»çµ± (å›°é›£)',
                description: 'åæŸãŒå›°é›£ãªã‚±ãƒ¼ã‚¹ï¼šé‡è² è·æ¡ä»¶',
                Ybus: [
                    [{ re: 8, im: -25 }, { re: -8, im: 25 }],
                    [{ re: -8, im: 25 }, { re: 8, im: -25 }]
                ],
                buses: [
                    { type: 'Slack', V: 1.0, delta: 0, P: 0, Q: 0 },
                    { type: 'PQ', V: 1.0, delta: 0, Pspec: -0.8, Qspec: -0.4 }
                ],
                solution: { V: 0.8654, delta: -0.1745 }, // Heavy loading
                initialPoint: { V: 1.3, delta: 0.3 }
            },
            'ieee5': {
                name: 'IEEE 5ãƒãƒ¼ãƒ‰ç³»çµ±',
                description: 'ä¸­è¦æ¨¡ç³»çµ±ï¼šè¤‡æ•°ç™ºé›»æ©Ÿãƒ»è² è·ã‚’å«ã‚€å®Ÿç”¨çš„ã‚·ã‚¹ãƒ†ãƒ ',
                Ybus: [
                    [{ re: 12.5, im: -37.5 }, { re: -5, im: 15 }, { re: -2.5, im: 7.5 }, { re: -5, im: 15 }, { re: 0, im: 0 }],
                    [{ re: -5, im: 15 }, { re: 8.33, im: -25 }, { re: -3.33, im: 10 }, { re: 0, im: 0 }, { re: 0, im: 0 }],
                    [{ re: -2.5, im: 7.5 }, { re: -3.33, im: 10 }, { re: 12.5, im: -37.5 }, { re: -3.33, im: 10 }, { re: -3.33, im: 10 }],
                    [{ re: -5, im: 15 }, { re: 0, im: 0 }, { re: -3.33, im: 10 }, { re: 11.66, im: -35 }, { re: -3.33, im: 10 }],
                    [{ re: 0, im: 0 }, { re: 0, im: 0 }, { re: -3.33, im: 10 }, { re: -3.33, im: 10 }, { re: 6.66, im: -20 }]
                ],
                buses: [
                    { type: 'Slack', V: 1.06, delta: 0, P: 0, Q: 0 },
                    { type: 'PV', V: 1.00, delta: 0, Pspec: 0.4, Q: 0 },
                    { type: 'PQ', V: 1.0, delta: 0, Pspec: -0.6, Qspec: -0.3 },
                    { type: 'PQ', V: 1.0, delta: 0, Pspec: -0.4, Qspec: -0.2 },
                    { type: 'PQ', V: 1.0, delta: 0, Pspec: -0.3, Qspec: -0.15 }
                ],
                // Solve for bus 3 (index 2) - primary load bus
                solution: { V: 0.956, delta: -0.087 }, // Estimated solution
                initialPoint: { V: 1.25, delta: 0.25 }
            },
            'voltage': {
                name: 'é›»åœ§å®‰å®šæ€§å•é¡Œ',
                description: 'é‡è² è·ã§ã®åæŸï¼ˆè§£ãŒ2ã¤ã‚ã‚‹å ´åˆï¼‰',
                Ybus: [
                    [{ re: 5, im: -15 }, { re: -5, im: 15 }],
                    [{ re: -5, im: 15 }, { re: 5, im: -15 }]
                ],
                buses: [
                    { type: 'Slack', V: 1.0, delta: 0, P: 0, Q: 0 },
                    { type: 'PQ', V: 1.0, delta: 0, Pspec: -1.2, Qspec: -0.5 }
                ],
                solution: { V: 0.7746, delta: -0.2618 },
                initialPoint: { V: 1.4, delta: 0.4 }
            }
        };

        // ============================================================
        // State
        // ============================================================
        let state = {
            problem: '2bus',
            algorithm: 'newton',
            speed: 1,
            running: false,
            iteration: 0,
            maxIterations: 100,      // å¢—åŠ 
            tolerance: 1e-10,        // é«˜ç²¾åº¦åŒ–
            
            // Current state
            V: 1.0,
            delta: 0,
            
            // History
            trajectory: [],
            errorHistory: [],
            
            // Animation
            animationId: null,
            
            // Enhanced precision tracking
            detailedTrajectory: [],  // ã‚ˆã‚Šè©³ç´°ãªè»Œè·¡
            convergenceRate: 0,      // åæŸç‡
            jacobianHistory: [],     // Jacobianè¡Œåˆ—å¼å±¥æ­´
            stepSizeHistory: [],     // ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºå±¥æ­´
            errorComponents: [],     // P, Qèª¤å·®æˆåˆ†åˆ¥
            adaptiveStep: true,      // é©å¿œã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º
            currentStepSize: 1.0,    // ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º
            dampingFactor: 0.8,      // ãƒ€ãƒ³ãƒ”ãƒ³ã‚°ä¿‚æ•°
            
            // Numerical stability
            minStepSize: 1e-6,       // æœ€å°ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º
            maxStepSize: 2.0,        // æœ€å¤§ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º
            jacobianlCondition: 0,   // Jacobianæ¡ä»¶æ•°
            
            // Visualization precision
            trajectoryDetail: 10,    // è»Œè·¡è£œé–“ç‚¹æ•°
            errorSurfaceResolution: 100, // èª¤å·®é¢è§£åƒåº¦
            showSubIterations: true  // ã‚µãƒ–åå¾©è¡¨ç¤º
        };

        // ============================================================
        // Initialize
        // ============================================================
        document.addEventListener('DOMContentLoaded', () => {
            initControls();
            reset();
            drawAll();
        });

        function initControls() {
            document.getElementById('algoSelect').addEventListener('change', e => {
                state.algorithm = e.target.value;
                reset();
            });

            document.getElementById('problemSelect').addEventListener('change', e => {
                state.problem = e.target.value;
                reset();
            });

            document.getElementById('speedSlider').addEventListener('input', e => {
                state.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = state.speed.toFixed(1) + 'x';
            });

            document.getElementById('runBtn').addEventListener('click', run);
            document.getElementById('stepBtn').addEventListener('click', step);
            document.getElementById('resetBtn').addEventListener('click', reset);
        }

        function reset() {
            state.running = false;
            state.iteration = 0;
            
            // Set initial point far from solution for better visualization
            const prob = problems[state.problem];
            const initial = prob.initialPoint || { V: 1.2, delta: 0.2 };
            state.V = initial.V;
            state.delta = initial.delta;
            
            // Reset all tracking arrays
            state.trajectory = [{ V: state.V, delta: state.delta }];
            state.errorHistory = [];
            state.detailedTrajectory = [];
            state.jacobianHistory = [];
            state.stepSizeHistory = [];
            state.errorComponents = [];
            state.convergenceRate = 0;
            state.currentStepSize = 1.0;

            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
            }

            updateDisplay();
            drawAll();
            updateEquation(`åˆæœŸçŠ¶æ…‹: V = ${state.V.toFixed(3)}, Î´ = ${(state.delta * 180 / Math.PI).toFixed(1)}Â°
            
ç›®æ¨™è§£: V = ${prob.solution.V.toFixed(3)}, Î´ = ${(prob.solution.delta * 180 / Math.PI).toFixed(1)}Â°
åˆæœŸèª¤å·®: ${getError(state.V, state.delta).toExponential(3)}`);
            
            document.querySelectorAll('.algo-step').forEach(s => {
                s.classList.remove('active', 'done');
            });
        }

        // ============================================================
        // Power Flow Calculations
        // ============================================================
        function calculateMismatch(V, delta) {
            const prob = problems[state.problem];
            const Ybus = prob.Ybus;
            
            // For simplicity, always solve for the main load bus
            let solverBusIndex;
            if (state.problem === 'ieee5') {
                solverBusIndex = 2; // Bus 3 - main load bus
            } else {
                solverBusIndex = 1; // Bus 2 for other systems
            }
            
            const bus = prob.buses[solverBusIndex];
            
            // Calculate P and Q at the solver bus
            let Pcalc = 0, Qcalc = 0;
            
            for (let j = 0; j < Ybus.length; j++) {
                let Vj, dj;
                if (j === 0) {
                    // Slack bus
                    Vj = prob.buses[0].V;
                    dj = 0;
                } else if (j === solverBusIndex) {
                    // Current bus being solved
                    Vj = V;
                    dj = delta;
                } else if (state.problem === 'ieee5' && j === 1) {
                    // PV bus (generator)
                    Vj = prob.buses[j].V; // Fixed voltage magnitude
                    dj = 0; // Assume zero angle for simplification
                } else {
                    // Other PQ buses - use nominal values for simplification
                    Vj = 1.0;
                    dj = 0;
                }
                
                const Gij = Ybus[solverBusIndex][j].re;
                const Bij = Ybus[solverBusIndex][j].im;
                const thetaij = (j === solverBusIndex ? 0 : delta - dj);
                
                Pcalc += V * Vj * (Gij * Math.cos(thetaij) + Bij * Math.sin(thetaij));
                Qcalc += V * Vj * (Gij * Math.sin(thetaij) - Bij * Math.cos(thetaij));
            }
            
            return {
                deltaP: bus.Pspec - Pcalc,
                deltaQ: bus.Qspec - Qcalc
            };
        }

        function getError(V, delta) {
            const m = calculateMismatch(V, delta);
            return Math.sqrt(m.deltaP * m.deltaP + m.deltaQ * m.deltaQ);
        }

        function calculateJacobian(V, delta) {
            const prob = problems[state.problem];
            const Ybus = prob.Ybus;
            
            // Determine solver bus index
            let solverBusIndex;
            if (state.problem === 'ieee5') {
                solverBusIndex = 2; // Bus 3 - main load bus
            } else {
                solverBusIndex = 1; // Bus 2 for other systems
            }
            
            const V1 = prob.buses[0].V; // Slack bus voltage
            
            // Get admittance matrix elements for solver bus
            const Gii = Ybus[solverBusIndex][solverBusIndex].re;
            const Bii = Ybus[solverBusIndex][solverBusIndex].im;
            const Gi1 = Ybus[solverBusIndex][0].re;
            const Bi1 = Ybus[solverBusIndex][0].im;
            
            // Simplified Jacobian for dominant coupling with slack bus
            // J11 = dP/d(delta) - primarily from coupling with slack
            const J11 = V * V1 * (Gi1 * Math.sin(delta) - Bi1 * Math.cos(delta));
            
            // J12 = dP/dV - self-admittance and coupling effects
            const J12 = 2 * V * Gii + V1 * (Gi1 * Math.cos(delta) + Bi1 * Math.sin(delta));
            
            // J21 = dQ/d(delta) 
            const J21 = -V * V1 * (Gi1 * Math.cos(delta) + Bi1 * Math.sin(delta));
            
            // J22 = dQ/dV
            const J22 = -2 * V * Bii + V1 * (Gi1 * Math.sin(delta) - Bi1 * Math.cos(delta));
            
            return { J11, J12, J21, J22 };
        }

        // ============================================================
        // Algorithm Implementations
        // ============================================================
        function doIteration() {
            const algo = state.algorithm;
            
            switch (algo) {
                case 'newton':
                    return newtonStep();
                case 'gauss-seidel':
                    return gaussSeidelStep();
                case 'gradient':
                    return gradientStep();
            }
        }

        function newtonStep() {
            const m = calculateMismatch(state.V, state.delta);
            const J = calculateJacobian(state.V, state.delta);
            
            // Calculate Jacobian determinant and condition number
            const det = J.J11 * J.J22 - J.J12 * J.J21;
            const jacNorm = Math.sqrt(J.J11*J.J11 + J.J12*J.J12 + J.J21*J.J21 + J.J22*J.J22);
            const invJacNorm = Math.abs(det) > 1e-15 ? Math.sqrt(
                (J.J22*J.J22 + J.J12*J.J12 + J.J21*J.J21 + J.J11*J.J11) / (det*det)
            ) : Infinity;
            state.jacobianlCondition = jacNorm * invJacNorm;
            
            // Store Jacobian determinant history
            state.jacobianHistory.push(Math.abs(det));
            
            // Check for singularity with higher precision
            if (Math.abs(det) < 1e-15 || !isFinite(det)) {
                return { converged: false, error: Infinity, singular: true };
            }
            
            // Calculate Newton direction with higher precision
            const dDelta = -(J.J22 * m.deltaP - J.J12 * m.deltaQ) / det;
            const dV = -(-J.J21 * m.deltaP + J.J11 * m.deltaQ) / det;
            
            // Adaptive step size based on error magnitude and Jacobian condition
            let stepSize = state.currentStepSize;
            const errorMagnitude = Math.sqrt(m.deltaP * m.deltaP + m.deltaQ * m.deltaQ);
            
            if (state.adaptiveStep) {
                // Reduce step size if error is large or Jacobian is ill-conditioned
                if (errorMagnitude > 1.0 || state.jacobianlCondition > 1e8) {
                    stepSize *= 0.5;
                } else if (errorMagnitude < 0.1 && state.jacobianlCondition < 1e4) {
                    stepSize = Math.min(stepSize * 1.2, state.maxStepSize);
                }
                stepSize = Math.max(state.minStepSize, Math.min(stepSize, state.maxStepSize));
                state.currentStepSize = stepSize;
            }
            
            // Apply damping with adaptive step size
            const damping = state.dampingFactor * stepSize;
            const oldV = state.V;
            const oldDelta = state.delta;
            
            state.delta += damping * dDelta;
            state.V += damping * dV;
            
            // Enhanced bounds with soft clamping
            if (state.V < 0.5) state.V = 0.5;
            else if (state.V > 1.5) state.V = 1.5;
            
            // Store detailed trajectory with intermediate points
            if (state.showSubIterations && state.trajectoryDetail > 1) {
                for (let i = 1; i <= state.trajectoryDetail; i++) {
                    const alpha = i / state.trajectoryDetail;
                    const interpV = oldV + alpha * damping * dV;
                    const interpDelta = oldDelta + alpha * damping * dDelta;
                    state.detailedTrajectory.push({ V: interpV, delta: interpDelta, 
                                                  subIteration: i, 
                                                  iteration: state.iteration });
                }
            }
            
            const error = getError(state.V, state.delta);
            
            // Store step size history
            state.stepSizeHistory.push(stepSize);
            
            // Store error components
            state.errorComponents.push({
                P: Math.abs(m.deltaP),
                Q: Math.abs(m.deltaQ),
                total: error,
                iteration: state.iteration,
                jacobianDet: Math.abs(det),
                condition: state.jacobianlCondition
            });
            
            // Calculate convergence rate
            if (state.errorHistory.length > 1) {
                const prevError = state.errorHistory[state.errorHistory.length - 1];
                if (prevError > 0 && error > 0) {
                    state.convergenceRate = Math.log(error / prevError);
                }
            }
            
            updateEquation(`Newton-Raphson ã‚¹ãƒ†ãƒƒãƒ— ${state.iteration + 1}:

ãƒŸã‚¹ãƒãƒƒãƒ: Î”P = ${m.deltaP.toFixed(4)}, Î”Q = ${m.deltaQ.toFixed(4)}

ãƒ¤ã‚³ãƒ“ã‚¢ãƒ³ J = [${J.J11.toFixed(3)}  ${J.J12.toFixed(3)}]
              [${J.J21.toFixed(3)}  ${J.J22.toFixed(3)}]

æ›´æ–°é‡: Î”Î´ = ${(dDelta * 180 / Math.PI).toFixed(4)}Â°, Î”V = ${dV.toFixed(4)}

<span class="eq-highlight">V = ${state.V.toFixed(4)}, Î´ = ${(state.delta * 180 / Math.PI).toFixed(2)}Â°</span>`);

            return { converged: error < state.tolerance, error };
        }

        function gaussSeidelStep() {
            const prob = problems[state.problem];
            const Ybus = prob.Ybus;
            const V1 = prob.buses[0].V;
            const bus = prob.buses[1];
            
            // Gauss-Seidel update
            const Y11 = { re: Ybus[1][1].re, im: Ybus[1][1].im };
            const Y12 = { re: Ybus[1][0].re, im: Ybus[1][0].im };
            
            // V2_new = (1/Y22) * ((P-jQ)/V2* - Y21*V1)
            const Vconj = { re: state.V * Math.cos(-state.delta), im: state.V * Math.sin(-state.delta) };
            const S = { re: bus.Pspec, im: -bus.Qspec };
            
            // S / V*
            const Vmag2 = state.V * state.V;
            const SoverV = {
                re: (S.re * Vconj.re - S.im * Vconj.im) / Vmag2,
                im: (S.re * Vconj.im + S.im * Vconj.re) / Vmag2
            };
            
            // Y12 * V1
            const YV1 = {
                re: Y12.re * V1,
                im: Y12.im * V1
            };
            
            // RHS = S/V* - Y12*V1
            const rhs = {
                re: SoverV.re - YV1.re,
                im: SoverV.im - YV1.im
            };
            
            // Divide by Y11
            const Y11mag2 = Y11.re * Y11.re + Y11.im * Y11.im;
            const newV = {
                re: (rhs.re * Y11.re + rhs.im * Y11.im) / Y11mag2,
                im: (rhs.im * Y11.re - rhs.re * Y11.im) / Y11mag2
            };
            
            const newMag = Math.sqrt(newV.re * newV.re + newV.im * newV.im);
            const newAngle = Math.atan2(newV.im, newV.re);
            
            // Relaxation
            const alpha = 1.2; // SOR factor
            const oldV = state.V;
            const oldDelta = state.delta;
            
            state.V = oldV + alpha * (newMag - oldV);
            state.delta = oldDelta + alpha * (newAngle - oldDelta);
            
            state.V = Math.max(0.7, Math.min(1.2, state.V));
            
            const error = getError(state.V, state.delta);
            
            updateEquation(`Gauss-Seidel ã‚¹ãƒ†ãƒƒãƒ— ${state.iteration + 1}:

Vâ‚‚ = (1/Yâ‚‚â‚‚) Ã— [(P-jQ)/Vâ‚‚* - Yâ‚‚â‚Ã—Vâ‚]

è¨ˆç®—:
  (P-jQ)/V* = ${SoverV.re.toFixed(4)} + j(${SoverV.im.toFixed(4)})
  Yâ‚‚â‚Ã—Vâ‚ = ${YV1.re.toFixed(4)} + j(${YV1.im.toFixed(4)})

æ–°ã—ã„ V = ${newMag.toFixed(4)}âˆ ${(newAngle * 180 / Math.PI).toFixed(2)}Â°

<span class="eq-highlight">ç·©å’Œå¾Œ: V = ${state.V.toFixed(4)}, Î´ = ${(state.delta * 180 / Math.PI).toFixed(2)}Â°</span>`);

            return { converged: error < state.tolerance, error };
        }

        function gradientStep() {
            const m = calculateMismatch(state.V, state.delta);
            
            // Gradient descent: x_new = x - Î± * gradient
            // Gradient of ||f||Â² = 2 * J^T * f
            const J = calculateJacobian(state.V, state.delta);
            
            const gradDelta = 2 * (J.J11 * m.deltaP + J.J21 * m.deltaQ);
            const gradV = 2 * (J.J12 * m.deltaP + J.J22 * m.deltaQ);
            
            const stepSize = 0.05; // Fixed small step size
            
            state.delta += stepSize * gradDelta;
            state.V += stepSize * gradV;
            
            state.V = Math.max(0.7, Math.min(1.2, state.V));
            
            const error = getError(state.V, state.delta);
            
            updateEquation(`å‹¾é…é™ä¸‹æ³• ã‚¹ãƒ†ãƒƒãƒ— ${state.iteration + 1}:

ç›®çš„é–¢æ•°: f = Î”PÂ² + Î”QÂ²

å‹¾é…: âˆ‡f = 2 Ã— Jáµ€ Ã— [Î”P, Î”Q]
     = [${gradDelta.toFixed(4)}, ${gradV.toFixed(4)}]

ã‚¹ãƒ†ãƒƒãƒ—å¹… Î± = ${stepSize}

<span class="eq-highlight">V = ${state.V.toFixed(4)}, Î´ = ${(state.delta * 180 / Math.PI).toFixed(2)}Â°</span>`);

            return { converged: error < state.tolerance, error };
        }

        // ============================================================
        // Running
        // ============================================================
        async function run() {
            if (state.running) return;
            
            state.running = true;
            document.getElementById('runBtn').disabled = true;
            document.getElementById('statusValue').textContent = 'å®Ÿè¡Œä¸­...';

            while (state.running && state.iteration < state.maxIterations) {
                await doStep();
                
                const error = state.errorHistory[state.errorHistory.length - 1];
                if (error < state.tolerance) {
                    document.getElementById('statusValue').textContent = 'åæŸ!';
                    break;
                }
                
                await delay(500 / state.speed);
            }

            if (state.iteration >= state.maxIterations) {
                document.getElementById('statusValue').textContent = 'æœªåæŸ';
            }

            state.running = false;
            document.getElementById('runBtn').disabled = false;
        }

        async function step() {
            if (state.running) return;
            await doStep();
        }

        async function doStep() {
            // Animate step indicators
            const steps = ['mismatch', 'jacobian', 'update', 'check'];
            
            for (let i = 0; i < 4; i++) {
                document.querySelectorAll('.algo-step').forEach((s, idx) => {
                    s.classList.remove('active');
                    if (idx <= i) s.classList.add('done');
                    if (idx === i + 1) s.classList.add('active');
                });
                await delay(100 / state.speed);
            }

            const result = doIteration();
            state.iteration++;
            
            state.trajectory.push({ V: state.V, delta: state.delta });
            state.errorHistory.push(result.error);
            
            updateDisplay();
            drawAll();

            document.querySelectorAll('.algo-step').forEach(s => {
                s.classList.remove('active');
                s.classList.add('done');
            });
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ============================================================
        // Display Updates
        // ============================================================
        function updateDisplay() {
            document.getElementById('iterValue').textContent = state.iteration;
            
            if (state.errorHistory.length > 0) {
                const error = state.errorHistory[state.errorHistory.length - 1];
                document.getElementById('errorValue').textContent = error.toExponential(2);
            }
            
            document.getElementById('voltageValue').textContent = state.V.toFixed(4);
            document.getElementById('angleValue').textContent = (state.delta * 180 / Math.PI).toFixed(2) + 'Â°';
            
            document.getElementById('trajectoryInfo').textContent = 
                `V = ${state.V.toFixed(3)}âˆ ${(state.delta * 180 / Math.PI).toFixed(1)}Â°`;
        }

        function updateEquation(text) {
            document.getElementById('equationBox').innerHTML = text;
        }

        // ============================================================
        // Drawing Functions
        // ============================================================
        function drawAll() {
            drawComplexPlane();
            drawErrorSurface();
            drawVectorField();
            drawConvergenceChart();
        }

        function drawComplexPlane() {
            const canvas = document.getElementById('complexPlane');
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            
            canvas.width = rect.width - 30;
            canvas.height = rect.height - 60;
            
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const scale = Math.min(w, h) * 0.35;

            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let r = 0.2; r <= 1.4; r += 0.2) {
                ctx.beginPath();
                ctx.arc(cx, cy, r * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#868e96';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText(r.toFixed(1), cx + r * scale + 5, cy);
            }

            // Axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();

            // Angle lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for (let a = 0; a < 360; a += 30) {
                const rad = a * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + 1.4 * scale * Math.cos(rad), cy - 1.4 * scale * Math.sin(rad));
                ctx.stroke();
            }

            // Draw solution point
            const prob = problems[state.problem];
            const solX = cx + prob.solution.V * Math.cos(prob.solution.delta) * scale;
            const solY = cy - prob.solution.V * Math.sin(prob.solution.delta) * scale;
            
            ctx.beginPath();
            ctx.arc(solX, solY, 12, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(81, 207, 102, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#51cf66';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#51cf66';
            ctx.font = 'bold 10px JetBrains Mono';
            ctx.fillText('è§£', solX + 15, solY);

            // Draw detailed trajectory
            if (state.detailedTrajectory.length > 1) {
                // Main trajectory
                ctx.beginPath();
                ctx.strokeStyle = '#ffa94d';
                ctx.lineWidth = 3;
                
                state.detailedTrajectory.forEach((point, i) => {
                    const x = cx + point.V * Math.cos(point.delta) * scale;
                    const y = cy - point.V * Math.sin(point.delta) * scale;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Sub-iteration points
                state.detailedTrajectory.forEach((point, i) => {
                    const x = cx + point.V * Math.cos(point.delta) * scale;
                    const y = cy - point.V * Math.sin(point.delta) * scale;
                    
                    if (point.subIteration === state.trajectoryDetail) {
                        // Major iteration points
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = '#ffa94d';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Label iteration number
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 10px JetBrains Mono';
                        ctx.fillText(point.iteration.toString(), x + 10, y - 10);
                    } else {
                        // Sub-iteration points
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 164, 77, 0.5)';
                        ctx.fill();
                    }
                });
            }
            
            // Fallback: standard trajectory if detailed not available
            else if (state.trajectory.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#ffa94d';
                ctx.lineWidth = 2;
                
                state.trajectory.forEach((point, i) => {
                    const x = cx + point.V * Math.cos(point.delta) * scale;
                    const y = cy - point.V * Math.sin(point.delta) * scale;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw points
                state.trajectory.forEach((point, i) => {
                    const x = cx + point.V * Math.cos(point.delta) * scale;
                    const y = cy - point.V * Math.sin(point.delta) * scale;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, i === state.trajectory.length - 1 ? 8 : 4, 0, 2 * Math.PI);
                    ctx.fillStyle = i === state.trajectory.length - 1 ? '#4dabf7' : '#ffa94d';
                    ctx.fill();
                    
                    // Iteration number
                    if (i > 0 && i < state.trajectory.length - 1) {
                        ctx.fillStyle = '#868e96';
                        ctx.font = '9px JetBrains Mono';
                        ctx.fillText(i.toString(), x + 6, y - 6);
                    }
                });
            } else {
                // Initial point
                const x = cx + state.V * Math.cos(state.delta) * scale;
                const y = cy - state.V * Math.sin(state.delta) * scale;
                
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#4dabf7';
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#e9ecef';
            ctx.font = '12px JetBrains Mono';
            ctx.fillText('Re(V)', w - 40, cy + 20);
            ctx.fillText('Im(V)', cx + 10, 20);
        }

        function drawErrorSurface() {
            const canvas = document.getElementById('errorSurface');
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            
            canvas.width = rect.width - 30;
            canvas.height = rect.height - 40;
            
            const w = canvas.width;
            const h = canvas.height;

            // Calculate error surface
            const resolution = 50;
            const Vmin = 0.7, Vmax = 1.2;
            const dMin = -0.3, dMax = 0.1;
            
            const errors = [];
            let maxError = 0;
            
            for (let i = 0; i < resolution; i++) {
                errors[i] = [];
                for (let j = 0; j < resolution; j++) {
                    const V = Vmin + (Vmax - Vmin) * i / resolution;
                    const delta = dMin + (dMax - dMin) * j / resolution;
                    const error = getError(V, delta);
                    errors[i][j] = error;
                    maxError = Math.max(maxError, error);
                }
            }

            // Draw as heatmap
            const cellW = w / resolution;
            const cellH = h / resolution;

            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const error = errors[i][j];
                    const normalized = Math.min(error / maxError, 1);
                    
                    // Color: blue (low) -> yellow -> red (high)
                    const hue = (1 - normalized) * 240;
                    ctx.fillStyle = `hsl(${hue}, 80%, ${30 + normalized * 30}%)`;
                    ctx.fillRect(j * cellW, (resolution - 1 - i) * cellH, cellW + 1, cellH + 1);
                }
            }

            // Draw trajectory on surface
            if (state.trajectory.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                
                state.trajectory.forEach((point, i) => {
                    const x = (point.delta - dMin) / (dMax - dMin) * w;
                    const y = (1 - (point.V - Vmin) / (Vmax - Vmin)) * h;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Current point
                const current = state.trajectory[state.trajectory.length - 1];
                const cx = (current.delta - dMin) / (dMax - dMin) * w;
                const cy = (1 - (current.V - Vmin) / (Vmax - Vmin)) * h;
                
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#ff6b6b';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Solution marker
            const prob = problems[state.problem];
            const solX = (prob.solution.delta - dMin) / (dMax - dMin) * w;
            const solY = (1 - (prob.solution.V - Vmin) / (Vmax - Vmin)) * h;
            
            ctx.beginPath();
            ctx.arc(solX, solY, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#51cf66';
            ctx.fill();

            // Axis labels
            ctx.fillStyle = '#e9ecef';
            ctx.font = '11px JetBrains Mono';
            ctx.fillText('Î´ â†’', w - 30, h - 5);
            ctx.fillText('|V| â†‘', 5, 15);
        }

        function drawVectorField() {
            const canvas = document.getElementById('vectorField');
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            
            canvas.width = rect.width - 30;
            canvas.height = rect.height - 40;
            
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            const Vmin = 0.7, Vmax = 1.2;
            const dMin = -0.3, dMax = 0.1;
            const gridSize = 12;

            const cellW = w / gridSize;
            const cellH = h / gridSize;

            // Draw vector field
            for (let i = 1; i < gridSize; i++) {
                for (let j = 1; j < gridSize; j++) {
                    const V = Vmin + (Vmax - Vmin) * i / gridSize;
                    const delta = dMin + (dMax - dMin) * j / gridSize;
                    
                    const m = calculateMismatch(V, delta);
                    const mag = Math.sqrt(m.deltaP * m.deltaP + m.deltaQ * m.deltaQ);
                    
                    if (mag < 0.001) continue;
                    
                    // Normalize
                    const scale = Math.min(mag * 50, 15);
                    const dx = m.deltaP / mag * scale;
                    const dy = -m.deltaQ / mag * scale;
                    
                    const cx = j * cellW;
                    const cy = (gridSize - i) * cellH;
                    
                    // Arrow color based on magnitude
                    const hue = (1 - Math.min(mag, 1)) * 120;
                    ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    
                    drawArrow(ctx, cx, cy, cx + dx * 2, cy + dy * 2);
                }
            }

            // Draw trajectory
            if (state.trajectory.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#4dabf7';
                ctx.lineWidth = 3;
                
                state.trajectory.forEach((point, i) => {
                    const x = (point.delta - dMin) / (dMax - dMin) * w;
                    const y = (1 - (point.V - Vmin) / (Vmax - Vmin)) * h;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Current point
                const current = state.trajectory[state.trajectory.length - 1];
                const cx = (current.delta - dMin) / (dMax - dMin) * w;
                const cy = (1 - (current.V - Vmin) / (Vmax - Vmin)) * h;
                
                ctx.beginPath();
                ctx.arc(cx, cy, 10, 0, 2 * Math.PI);
                ctx.fillStyle = '#4dabf7';
                ctx.fill();
            }

            // Solution point
            const prob = problems[state.problem];
            const solX = (prob.solution.delta - dMin) / (dMax - dMin) * w;
            const solY = (1 - (prob.solution.V - Vmin) / (Vmax - Vmin)) * h;
            
            ctx.beginPath();
            ctx.arc(solX, solY, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#51cf66';
            ctx.fill();
            
            ctx.fillStyle = '#51cf66';
            ctx.font = 'bold 11px JetBrains Mono';
            ctx.fillText('è§£', solX + 12, solY + 4);

            // Labels
            ctx.fillStyle = '#e9ecef';
            ctx.font = '11px JetBrains Mono';
            ctx.fillText('Î´ â†’', w - 30, h - 5);
            ctx.fillText('|V| â†‘', 5, 15);
        }

        function drawArrow(ctx, x1, y1, x2, y2) {
            const headLen = 6;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawConvergenceChart() {
            const canvas = document.getElementById('convergenceChart');
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            
            canvas.width = rect.width - 30;
            canvas.height = rect.height - 60;
            
            const w = canvas.width;
            const h = canvas.height;
            const padding = { top: 30, right: 120, bottom: 50, left: 80 };

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            if (state.errorHistory.length === 0) {
                ctx.fillStyle = '#868e96';
                ctx.font = '12px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText('å®Ÿè¡Œã™ã‚‹ã¨è©³ç´°åæŸæƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™', w / 2, h / 2);
                return;
            }

            const data = state.errorHistory;
            const errorComponents = state.errorComponents;
            const jacobianHist = state.jacobianHistory;
            const stepSizeHist = state.stepSizeHistory;
            
            // Calculate plot area - split into two subplots
            const plotW = w - padding.left - padding.right;
            const plotH1 = (h - padding.top - padding.bottom) * 0.7; // Error plot
            const plotH2 = (h - padding.top - padding.bottom) * 0.25; // Jacobian/Step size plot
            const gap = 15;
            
            // === Main Error Plot ===
            const logData = data.map(d => Math.log10(Math.max(d, 1e-15)));
            const minLog = Math.min(...logData, Math.log10(state.tolerance)) - 1;
            const maxLog = Math.max(...logData) + 0.5;
            const xScale = plotW / Math.max(data.length, 10);

            // Background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 6; i++) {
                const y = padding.top + i * plotH1 / 6;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + plotW, y);
                ctx.stroke();
            }

            // Tolerance line
            const tolY = padding.top + (maxLog - Math.log10(state.tolerance)) / (maxLog - minLog) * plotH1;
            ctx.strokeStyle = '#ff6b6b';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, tolY);
            ctx.lineTo(padding.left + plotW, tolY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Total error curve
            ctx.beginPath();
            ctx.strokeStyle = '#4dabf7';
            ctx.lineWidth = 3;
            data.forEach((val, i) => {
                const x = padding.left + (i + 1) * xScale;
                const y = padding.top + (maxLog - Math.log10(Math.max(val, 1e-15))) / (maxLog - minLog) * plotH1;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // P and Q error components if available
            if (errorComponents.length > 0) {
                // P error curve
                ctx.beginPath();
                ctx.strokeStyle = '#51cf66';
                ctx.lineWidth = 2;
                errorComponents.forEach((comp, i) => {
                    const x = padding.left + (i + 1) * xScale;
                    const y = padding.top + (maxLog - Math.log10(Math.max(comp.P, 1e-15))) / (maxLog - minLog) * plotH1;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Q error curve
                ctx.beginPath();
                ctx.strokeStyle = '#ffa94d';
                ctx.lineWidth = 2;
                errorComponents.forEach((comp, i) => {
                    const x = padding.left + (i + 1) * xScale;
                    const y = padding.top + (maxLog - Math.log10(Math.max(comp.Q, 1e-15))) / (maxLog - minLog) * plotH1;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            // Current point with enhanced info
            if (data.length > 0) {
                const lastIdx = data.length - 1;
                const x = padding.left + data.length * xScale;
                const y = padding.top + (maxLog - Math.log10(Math.max(data[lastIdx], 1e-15))) / (maxLog - minLog) * plotH1;
                
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#4dabf7';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Convergence rate indicator
                if (state.convergenceRate && state.convergenceRate < 0) {
                    const rate = Math.abs(state.convergenceRate);
                    const rateText = rate > 1 ? 'äºŒæ¬¡åæŸ' : rate > 0.5 ? 'æº–äºŒæ¬¡åæŸ' : 'ä¸€æ¬¡åæŸ';
                    ctx.fillStyle = rate > 1 ? '#51cf66' : rate > 0.5 ? '#ffa94d' : '#ff6b6b';
                    ctx.font = 'bold 10px JetBrains Mono';
                    ctx.fillText(rateText, x + 12, y - 10);
                    ctx.fillText(`r=${rate.toFixed(2)}`, x + 12, y + 5);
                }
            }

            // === Secondary Plot (Jacobian Det & Step Size) ===
            const plot2Y = padding.top + plotH1 + gap;
            
            // Jacobian determinant plot
            if (jacobianHist.length > 0) {
                const logJacData = jacobianHist.map(d => Math.log10(Math.max(d, 1e-15)));
                const jacMin = Math.min(...logJacData) - 0.5;
                const jacMax = Math.max(...logJacData) + 0.5;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                for (let i = 0; i <= 3; i++) {
                    const y = plot2Y + i * plotH2 / 3;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(padding.left + plotW, y);
                    ctx.stroke();
                }
                
                ctx.beginPath();
                ctx.strokeStyle = '#cc5de8';
                ctx.lineWidth = 2;
                jacobianHist.forEach((val, i) => {
                    const x = padding.left + (i + 1) * xScale;
                    const y = plot2Y + (jacMax - Math.log10(Math.max(val, 1e-15))) / (jacMax - jacMin) * plotH2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Singularity warning line
                const singY = plot2Y + (jacMax - Math.log10(1e-12)) / (jacMax - jacMin) * plotH2;
                if (singY >= plot2Y && singY <= plot2Y + plotH2) {
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(padding.left, singY);
                    ctx.lineTo(padding.left + plotW, singY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Step size overlay
            if (stepSizeHist.length > 0) {
                const stepMin = Math.min(...stepSizeHist);
                const stepMax = Math.max(...stepSizeHist);
                if (stepMax > stepMin) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#22b8cf';
                    ctx.lineWidth = 1;
                    stepSizeHist.forEach((val, i) => {
                        const x = padding.left + (i + 1) * xScale;
                        const y = plot2Y + plotH2 - ((val - stepMin) / (stepMax - stepMin)) * plotH2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                }
            }

            // === Labels and Legends ===
            ctx.fillStyle = '#e9ecef';
            ctx.font = '11px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText('åå¾©å›æ•°', w / 2, h - 5);

            // Y-axis labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const logVal = maxLog - i * (maxLog - minLog) / 4;
                const y = padding.top + i * plotH1 / 4;
                ctx.fillText(logVal.toFixed(1), padding.left - 5, y + 4);
            }

            // Legend
            const legendX = w - padding.right + 10;
            let legendY = padding.top;
            ctx.textAlign = 'left';
            ctx.font = '10px JetBrains Mono';
            
            // Error components legend
            const legendItems = [
                { color: '#4dabf7', label: 'ç·èª¤å·®', width: 3 },
                { color: '#51cf66', label: 'Pèª¤å·®', width: 2 },
                { color: '#ffa94d', label: 'Qèª¤å·®', width: 2 },
                { color: '#ff6b6b', label: 'è¨±å®¹å€¤', width: 1, dash: [5,5] },
                { color: '#cc5de8', label: 'log|det(J)|', width: 2 },
                { color: '#22b8cf', label: 'ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º', width: 1 }
            ];
            
            legendItems.forEach((item, i) => {
                const y = legendY + i * 18;
                ctx.strokeStyle = item.color;
                ctx.lineWidth = item.width;
                if (item.dash) ctx.setLineDash(item.dash);
                
                ctx.beginPath();
                ctx.moveTo(legendX, y);
                ctx.lineTo(legendX + 20, y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = item.color;
                ctx.fillText(item.label, legendX + 25, y + 3);
            });

            // Current statistics
            if (data.length > 0) {
                const statsY = legendY + legendItems.length * 18 + 20;
                ctx.fillStyle = '#e9ecef';
                ctx.font = 'bold 10px JetBrains Mono';
                ctx.fillText('ç¾åœ¨ã®çŠ¶æ…‹:', legendX, statsY);
                
                const stats = [
                    `åå¾©: ${state.iteration}`,
                    `èª¤å·®: ${data[data.length-1].toExponential(2)}`,
                    `åæŸ: ${data[data.length-1] < state.tolerance ? 'âœ“' : 'Ã—'}`,
                ];
                
                if (state.jacobianlCondition) {
                    stats.push(`æ¡ä»¶æ•°: ${state.jacobianlCondition.toExponential(1)}`);
                }
                if (state.currentStepSize) {
                    stats.push(`ã‚¹ãƒ†ãƒƒãƒ—: ${state.currentStepSize.toFixed(3)}`);
                }
                
                ctx.font = '9px JetBrains Mono';
                stats.forEach((stat, i) => {
                    ctx.fillText(stat, legendX, statsY + 15 + i * 12);
                });
            }

            // Axis titles
            ctx.fillStyle = '#e9ecef';
            ctx.font = '11px JetBrains Mono';
            ctx.save();
            ctx.translate(15, padding.top + plotH1 / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('logâ‚â‚€(èª¤å·®)', 0, 0);
            ctx.restore();
            
            ctx.save();
            ctx.translate(15, plot2Y + plotH2 / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('logâ‚â‚€|det(J)|', 0, 0);
            ctx.restore();
        }

        // Resize
        window.addEventListener('resize', drawAll);
    </script>
</body>
</html>
