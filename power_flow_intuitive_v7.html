<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ½®æµè¨ˆç®— åæŸå¯è¦–åŒ– v7 (å®‰å®šç‰ˆ)</title>
    <style>
        :root {
            --bg-dark: #0f0f1a;
            --bg-card: #1a1a2e;
            --bg-surface: #252540;
            --accent-blue: #4dabf7;
            --accent-green: #51cf66;
            --accent-orange: #ffa94d;
            --accent-red: #ff6b6b;
            --accent-purple: #cc5de8;
            --accent-cyan: #22b8cf;
            --text-primary: #e9ecef;
            --text-secondary: #868e96;
            --border: #3d3d5c;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 15px; }
        header { text-align: center; padding: 15px 0; border-bottom: 1px solid var(--border); margin-bottom: 15px; }
        h1 { font-size: 1.6rem; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-secondary); font-size: 0.9rem; }
        
        .control-panel {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-group label { font-size: 0.8rem; color: var(--text-secondary); }
        select, input[type="number"] {
            background: var(--bg-surface);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
        }
        input[type="number"] { width: 80px; }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); color: var(--bg-dark); }
        .btn-secondary { background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border); }
        .btn:hover { transform: translateY(-1px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
        .viz-card { background: var(--bg-card); border-radius: 10px; overflow: hidden; }
        .viz-header { padding: 10px 15px; border-bottom: 1px solid var(--border); font-size: 0.95rem; font-weight: 600; }
        .viz-body { padding: 10px; height: 350px; position: relative; }
        .viz-body canvas { width: 100%; height: 100%; }
        
        .info-panel {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }
        .info-stat { background: var(--bg-surface); padding: 12px; border-radius: 6px; text-align: center; }
        .info-value { font-size: 1.4rem; font-weight: 600; color: var(--accent-cyan); font-family: monospace; }
        .info-label { font-size: 0.7rem; color: var(--text-secondary); text-transform: uppercase; margin-top: 3px; }
        
        .log-panel {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
        }
        .log-panel h3 { font-size: 0.95rem; margin-bottom: 10px; color: var(--accent-cyan); }
        #logOutput {
            background: var(--bg-surface);
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.75rem;
            height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .log-success { color: var(--accent-green); }
        .log-warning { color: var(--accent-orange); }
        .log-error { color: var(--accent-red); }
        .log-info { color: var(--accent-cyan); }
        
        @media (max-width: 900px) { .main-grid { grid-template-columns: 1fr; } }

        /* Navigation Bar */
        .nav-bar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 8px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--text-primary);
        }

        .nav-logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .nav-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .nav-links {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-link:hover {
            background: var(--bg-surface);
            color: var(--accent-cyan);
        }

        .nav-link.primary {
            background: var(--accent-cyan);
            color: var(--bg-dark);
            font-weight: 500;
        }

        .nav-link.primary:hover {
            background: var(--accent-green);
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="nav-bar">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">
                <div class="nav-logo-icon">âš¡</div>
                <span class="nav-title">Power Flow Visualization</span>
            </a>
            <div class="nav-links">
                <a href="index.html" class="nav-link primary">ğŸ  ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</a>
                <a href="https://github.com/lutelute/power_flow_viz" class="nav-link" target="_blank">ğŸ“ GitHub</a>
            </div>
        </div>
    </nav>
    <div class="container">
        <header>
            <h1>âš¡ æ½®æµè¨ˆç®— åæŸã®å¯è¦–åŒ– v7 (å®‰å®šç‰ˆ)</h1>
            <p class="subtitle">Newton-Raphsonæ³•ã€Gauss-Seidelæ³•ã€å‹¾é…é™ä¸‹æ³•ã€DCæ½®æµæ³•ã®æ¯”è¼ƒ - 10ãƒãƒ¼ãƒ‰å¯¾å¿œ</p>
        </header>

        <div class="control-panel">
            <div class="control-group">
                <label>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ :</label>
                <select id="algoSelect">
                    <option value="newton">Newton-Raphsonæ³•ï¼ˆæ¨™æº–ãƒ»é«˜é€Ÿï¼‰</option>
                    <option value="gauss-seidel">Gauss-Seidelæ³•ï¼ˆåæŸé…ã„å ´åˆã‚ã‚Šï¼‰</option>
                    <option value="gradient">å‹¾é…é™ä¸‹æ³•ï¼ˆæ•°å€¤å‹¾é…ï¼‰</option>
                    <option value="dc">DCæ½®æµæ³•ï¼ˆç·šå½¢è¿‘ä¼¼ï¼‰</option>
                </select>
            </div>
            <div class="control-group">
                <label>å•é¡Œ:</label>
                <select id="problemSelect">
                    <option value="2bus_light">2ãƒãƒ¼ãƒ‰(è»½è² è·) - ç°¡å˜</option>
                    <option value="2bus_medium">2ãƒãƒ¼ãƒ‰(ä¸­è² è·) - æ¨™æº–</option>
                    <option value="2bus_heavy">2ãƒãƒ¼ãƒ‰(é‡è² è·) - ã‚„ã‚„å›°é›£</option>
                    <option value="2bus_critical">2ãƒãƒ¼ãƒ‰(è‡¨ç•Œè² è·) - å›°é›£</option>
                    <option value="2bus_voltage_collapse">2ãƒãƒ¼ãƒ‰(é›»åœ§å´©å£Šç›´å‰) - éå¸¸ã«å›°é›£</option>
                    <option value="3bus_unbalanced">3ãƒãƒ¼ãƒ‰(ä¸å¹³è¡¡è² è·) - å›°é›£</option>
                    <option value="3bus">3ãƒãƒ¼ãƒ‰ç³»çµ± - æ¨™æº–</option>
                    <option value="5bus_ieee">5ãƒãƒ¼ãƒ‰(IEEE) - ä¸­è¦æ¨¡</option>
                    <option value="9bus_ieee">9ãƒãƒ¼ãƒ‰(IEEE) - å¤§è¦æ¨¡</option>
                    <option value="10bus_simple">10ãƒãƒ¼ãƒ‰(ç°¡æ˜“) - å®‰å®šå‹•ä½œç¢ºèªæ¸ˆã¿</option>
                </select>
            </div>
            <div class="control-group">
                <label>è¨±å®¹èª¤å·®:</label>
                <input type="number" id="toleranceInput" value="1e-6" step="1e-7" min="1e-12" max="1e-2">
            </div>
            <div class="control-group">
                <label>é€Ÿåº¦:</label>
                <input type="range" id="speedSlider" min="0.5" max="5" step="0.5" value="2" style="width:100px;">
                <span id="speedValue">2.0x</span>
            </div>
            <div class="control-group">
                <button class="btn btn-primary" id="runBtn">â–¶ å®Ÿè¡Œ</button>
                <button class="btn btn-secondary" id="stepBtn">â­ 1ã‚¹ãƒ†ãƒƒãƒ—</button>
                <button class="btn btn-secondary" id="resetBtn">â†º ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-grid">
                <div class="info-stat">
                    <div class="info-value" id="iterValue">0</div>
                    <div class="info-label">åå¾©å›æ•°</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="errorValue">-</div>
                    <div class="info-label">èª¤å·® ||Î”S||</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="voltageValue">-</div>
                    <div class="info-label">é›»åœ§ |Vâ‚‚|</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="angleValue">-</div>
                    <div class="info-label">ä½ç›¸è§’ Î´â‚‚</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="trueVValue">-</div>
                    <div class="info-label">çœŸã®è§£ |V|</div>
                </div>
                <div class="info-stat">
                    <div class="info-value" id="trueDeltaValue">-</div>
                    <div class="info-label">çœŸã®è§£ Î´</div>
                </div>
            </div>
            <div id="diagnosisPanel" style="margin-top: 12px; padding: 10px; border-radius: 6px; display: none;">
                <div style="font-weight: 600; margin-bottom: 5px;" id="diagnosisTitle"></div>
                <div style="font-size: 0.85rem;" id="diagnosisDesc"></div>
                <div style="font-size: 0.8rem; margin-top: 5px; opacity: 0.8;" id="diagnosisHint"></div>
            </div>
        </div>

        <div class="main-grid">
            <div class="viz-card">
                <div class="viz-header">ğŸ“ è¤‡ç´ é›»åœ§å¹³é¢</div>
                <div class="viz-body"><canvas id="complexPlane"></canvas></div>
            </div>
            <div class="viz-card">
                <div class="viz-header">ğŸ”ï¸ èª¤å·®æ›²é¢ (è°·åº•ãŒè§£)</div>
                <div class="viz-body"><canvas id="errorSurface"></canvas></div>
            </div>
            <div class="viz-card">
                <div class="viz-header">ğŸ“ˆ åæŸå±¥æ­´ (å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«)</div>
                <div class="viz-body"><canvas id="convergenceChart"></canvas></div>
            </div>
            <div class="viz-card">
                <div class="viz-header">ğŸ§­ ãƒŸã‚¹ãƒãƒƒãƒãƒ™ã‚¯ãƒˆãƒ«å ´</div>
                <div class="viz-body"><canvas id="vectorField"></canvas></div>
            </div>
        </div>

        <div class="log-panel">
            <h3>ğŸ“ è¨ˆç®—ãƒ­ã‚°</h3>
            <div id="logOutput">åˆæœŸåŒ–å®Œäº†ã€‚å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>
        </div>
    </div>

    <script>
    // ================================================================
    // å•é¡Œå®šç¾©
    // ================================================================
    const problems = {
        '2bus_light': {
            name: '2ãƒãƒ¼ãƒ‰(è»½è² è·)',
            // Y = [10-j30, -10+j30; -10+j30, 10-j30]
            Ybus: [[{re:10,im:-30}, {re:-10,im:30}], [{re:-10,im:30}, {re:10,im:-30}]],
            buses: [
                { type:'Slack', V:1.0, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.3, Qspec:-0.1 }
            ],
            solverBus: 1,
            initialV: 1.05, initialDelta: 0.05
        },
        '2bus_medium': {
            name: '2ãƒãƒ¼ãƒ‰(ä¸­è² è·)',
            Ybus: [[{re:10,im:-30}, {re:-10,im:30}], [{re:-10,im:30}, {re:10,im:-30}]],
            buses: [
                { type:'Slack', V:1.0, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.5, Qspec:-0.2 }
            ],
            solverBus: 1,
            initialV: 1.05, initialDelta: 0.05
        },
        '2bus_heavy': {
            name: '2ãƒãƒ¼ãƒ‰(é‡è² è·)',
            Ybus: [[{re:10,im:-30}, {re:-10,im:30}], [{re:-10,im:30}, {re:10,im:-30}]],
            buses: [
                { type:'Slack', V:1.0, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.9, Qspec:-0.4 }
            ],
            solverBus: 1,
            initialV: 1.1, initialDelta: 0.1
        },
        '2bus_critical': {
            name: '2ãƒãƒ¼ãƒ‰(è‡¨ç•Œè² è·) - åæŸå›°é›£',
            Ybus: [[{re:8,im:-25}, {re:-8,im:25}], [{re:-8,im:25}, {re:8,im:-25}]],
            buses: [
                { type:'Slack', V:1.0, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-1.1, Qspec:-0.5 }
            ],
            solverBus: 1,
            initialV: 1.2, initialDelta: 0.15
        },
        '2bus_voltage_collapse': {
            name: '2ãƒãƒ¼ãƒ‰(é›»åœ§å´©å£Šç›´å‰) - éå¸¸ã«å›°é›£',
            Ybus: [[{re:6,im:-20}, {re:-6,im:20}], [{re:-6,im:20}, {re:6,im:-20}]],
            buses: [
                { type:'Slack', V:1.0, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-1.4, Qspec:-0.7 }
            ],
            solverBus: 1,
            initialV: 1.3, initialDelta: 0.2
        },
        '3bus_unbalanced': {
            name: '3ãƒãƒ¼ãƒ‰(ä¸å¹³è¡¡è² è·) - åæŸå›°é›£',
            // ä¸å¹³è¡¡ãªè² è·åˆ†å¸ƒã§åæŸãŒå›°é›£
            Ybus: [
                [{re:12,im:-35}, {re:-6,im:18}, {re:-6,im:17}],
                [{re:-6,im:18}, {re:15,im:-45}, {re:-9,im:27}],
                [{re:-6,im:17}, {re:-9,im:27}, {re:15,im:-44}]
            ],
            buses: [
                { type:'Slack', V:1.05, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.8, Qspec:-0.4 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.2, Qspec:-0.05 }
            ],
            solverBus: 1,
            initialV: 1.25, initialDelta: 0.18
        },
        '3bus': {
            name: '3ãƒãƒ¼ãƒ‰ç³»çµ±',
            // ç°¡å˜ãª3ãƒã‚¹: Slack - PQ - PQ (ç›´åˆ—æ¥ç¶š)
            Ybus: [
                [{re:10,im:-30}, {re:-10,im:30}, {re:0,im:0}],
                [{re:-10,im:30}, {re:20,im:-60}, {re:-10,im:30}],
                [{re:0,im:0}, {re:-10,im:30}, {re:10,im:-30}]
            ],
            buses: [
                { type:'Slack', V:1.0, delta:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.4, Qspec:-0.15 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.3, Qspec:-0.1 }
            ],
            solverBus: 1,  // ãƒã‚¹2ã‚’ä¸»ã«å¯è¦–åŒ–
            initialV: 1.05, initialDelta: 0.05
        },
        '5bus_ieee': {
            name: '5ãƒãƒ¼ãƒ‰(IEEE) - ä¸­è¦æ¨¡ç³»çµ±',
            // IEEE 5ãƒã‚¹ä¿®æ­£ç‰ˆ
            Ybus: [
                [{re:12.5,im:-37.5}, {re:-5,im:15}, {re:-2.5,im:7.5}, {re:-5,im:15}, {re:0,im:0}],
                [{re:-5,im:15}, {re:8.33,im:-25}, {re:-3.33,im:10}, {re:0,im:0}, {re:0,im:0}],
                [{re:-2.5,im:7.5}, {re:-3.33,im:10}, {re:12.5,im:-37.5}, {re:-3.33,im:10}, {re:-3.33,im:10}],
                [{re:-5,im:15}, {re:0,im:0}, {re:-3.33,im:10}, {re:11.66,im:-35}, {re:-3.33,im:10}],
                [{re:0,im:0}, {re:0,im:0}, {re:-3.33,im:10}, {re:-3.33,im:10}, {re:6.66,im:-20}]
            ],
            buses: [
                { type:'Slack', V:1.06, delta:0 },
                { type:'PV', V:1.00, delta:0, Pspec:0.4 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.6, Qspec:-0.3 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.4, Qspec:-0.2 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.3, Qspec:-0.15 }
            ],
            solverBus: 2,  // ãƒã‚¹3 (ä¸»è² è·) ã‚’å¯è¦–åŒ–
            initialV: 1.15, initialDelta: 0.12
        },
        '9bus_ieee': {
            name: '9ãƒãƒ¼ãƒ‰(IEEE) - å¤§è¦æ¨¡ç³»çµ±',
            // IEEE 9ãƒã‚¹ç³»çµ±ã®ç°¡ç•¥ç‰ˆ (WSCC 3-machine 9-bus)
            Ybus: [
                [{re:10.4,im:-31.2}, {re:-4.2,im:12.6}, {re:0,im:0}, {re:-6.2,im:18.6}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                [{re:-4.2,im:12.6}, {re:8.7,im:-26.1}, {re:-4.5,im:13.5}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                [{re:0,im:0}, {re:-4.5,im:13.5}, {re:9.3,im:-27.9}, {re:0,im:0}, {re:0,im:0}, {re:-4.8,im:14.4}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                [{re:-6.2,im:18.6}, {re:0,im:0}, {re:0,im:0}, {re:11.5,im:-34.5}, {re:-2.8,im:8.4}, {re:0,im:0}, {re:-2.5,im:7.5}, {re:0,im:0}, {re:0,im:0}],
                [{re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-2.8,im:8.4}, {re:7.6,im:-22.8}, {re:-4.8,im:14.4}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                [{re:0,im:0}, {re:0,im:0}, {re:-4.8,im:14.4}, {re:0,im:0}, {re:-4.8,im:14.4}, {re:12.1,im:-36.3}, {re:0,im:0}, {re:0,im:0}, {re:-2.5,im:7.5}],
                [{re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-2.5,im:7.5}, {re:0,im:0}, {re:0,im:0}, {re:5.8,im:-17.4}, {re:-3.3,im:9.9}, {re:0,im:0}],
                [{re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-3.3,im:9.9}, {re:6.1,im:-18.3}, {re:-2.8,im:8.4}],
                [{re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-2.5,im:7.5}, {re:0,im:0}, {re:-2.8,im:8.4}, {re:5.3,im:-15.9}]
            ],
            buses: [
                { type:'Slack', V:1.04, delta:0 },
                { type:'PV', V:1.025, delta:0, Pspec:1.63 },
                { type:'PV', V:1.025, delta:0, Pspec:0.85 },
                { type:'PQ', V:1.0, delta:0, Pspec:0, Qspec:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-1.25, Qspec:-0.5 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.9, Qspec:-0.3 },
                { type:'PQ', V:1.0, delta:0, Pspec:0, Qspec:0 },
                { type:'PQ', V:1.0, delta:0, Pspec:-1.0, Qspec:-0.35 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.125, Qspec:-0.05 }
            ],
            solverBus: 4,  // ãƒã‚¹5 (æœ€å¤§è² è·) ã‚’å¯è¦–åŒ–
            initialV: 1.2, initialDelta: 0.15
        },
        '10bus_simple': {
            name: '10ãƒãƒ¼ãƒ‰(ç°¡æ˜“) - å®‰å®šå‹•ä½œç¢ºèªæ¸ˆã¿',
            // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒªãƒ³ã‚° + ä¸­å¤®ãƒãƒ–æ§‹é€ 
            Ybus: [
                // Bus 0 (Slack)
                [{re:15,im:-45}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}],
                // Bus 1 (PV)  
                [{re:-5,im:15}, {re:20,im:-60}, {re:-5,im:15}, {re:0,im:0}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:0,im:0}],
                // Bus 2 (PQ)
                [{re:0,im:0}, {re:-5,im:15}, {re:15,im:-45}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                // Bus 3 (PQ)
                [{re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:10,im:-30}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                // Bus 4 (PQ) - Solver Bus
                [{re:0,im:0}, {re:-5,im:15}, {re:0,im:0}, {re:-5,im:15}, {re:15,im:-45}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                // Bus 5 (PQ)
                [{re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:15,im:-45}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}],
                // Bus 6 (PQ)
                [{re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:15,im:-45}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}],
                // Bus 7 (PQ)
                [{re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:15,im:-45}, {re:-5,im:15}, {re:0,im:0}],
                // Bus 8 (PQ)
                [{re:0,im:0}, {re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:15,im:-45}, {re:-5,im:15}],
                // Bus 9 (PQ)
                [{re:-5,im:15}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:0,im:0}, {re:-5,im:15}, {re:10,im:-30}]
            ],
            buses: [
                { type:'Slack', V:1.05, delta:0 },
                { type:'PV', V:1.02, delta:0, Pspec:0.8 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.2, Qspec:-0.1 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.15, Qspec:-0.08 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.3, Qspec:-0.15 }, // Solver Bus
                { type:'PQ', V:1.0, delta:0, Pspec:-0.25, Qspec:-0.12 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.18, Qspec:-0.09 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.22, Qspec:-0.11 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.28, Qspec:-0.14 },
                { type:'PQ', V:1.0, delta:0, Pspec:-0.16, Qspec:-0.08 }
            ],
            solverBus: 4,  // ãƒã‚¹5 (ä¸­å¤®ã®è² è·ãƒã‚¹) ã‚’å¯è¦–åŒ–
            initialV: 1.05, initialDelta: 0.08
        }
    };

    // ================================================================
    // çŠ¶æ…‹ç®¡ç†
    // ================================================================
    let state = {
        problem: '2bus_medium',
        algorithm: 'newton',
        tolerance: 1e-6,
        speed: 2,
        running: false,
        iteration: 0,
        maxIterations: 500,  // å›°é›£ãªå•é¡Œã«å¯¾å¿œ
        V: 1.0,
        delta: 0,
        trajectory: [],
        errorHistory: [],
        trueSolution: null,
        dcSolution: null,
        // è¨ºæ–­ç”¨
        stuckCount: 0,
        oscillationCount: 0,
        divergenceCount: 0,
        lastErrors: [],  // ç›´è¿‘ã®ã‚¨ãƒ©ãƒ¼å±¥æ­´ï¼ˆæŒ¯å‹•æ¤œå‡ºç”¨ï¼‰
        diagnosisResult: null
    };

    // ================================================================
    // åæŸè¨ºæ–­
    // ================================================================
    const DIAGNOSIS = {
        CONVERGED: { code: 'converged', label: 'âœ“ åæŸ', color: 'success', 
            desc: 'è¨±å®¹èª¤å·®ä»¥å†…ã«åæŸã—ã¾ã—ãŸã€‚' },
        OSCILLATING: { code: 'oscillating', label: 'âš  æŒ¯å‹•', color: 'warning',
            desc: 'è§£ã®è¿‘å‚ã§æŒ¯å‹•ã—ã¦ã„ã¾ã™ã€‚ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºã‚’å°ã•ãã™ã‚‹ã‹ã€ãƒ€ãƒ³ãƒ”ãƒ³ã‚°ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚' },
        STUCK: { code: 'stuck', label: 'âš  åœæ»', color: 'warning',
            desc: 'æ”¹å–„ãŒè¦‹ã‚‰ã‚Œã¾ã›ã‚“ã€‚åˆæœŸç‚¹ã‚’å¤‰æ›´ã™ã‚‹ã‹ã€åˆ¥ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚' },
        DIVERGING: { code: 'diverging', label: 'âœ— ç™ºæ•£', color: 'error',
            desc: 'èª¤å·®ãŒå¢—å¤§ã—ã¦ã„ã¾ã™ã€‚åˆæœŸç‚¹ãŒè§£ã‹ã‚‰é ã™ãã‚‹ã‹ã€è§£ãŒå­˜åœ¨ã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚' },
        SINGULAR: { code: 'singular', label: 'âœ— ç‰¹ç•°', color: 'error',
            desc: 'JacobianãŒç‰¹ç•°ã§ã™ã€‚é›»åœ§å´©å£Šç‚¹ã«è¿‘ã„ã‹ã€å•é¡Œè¨­å®šã«èª¤ã‚ŠãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚' },
        SLOW_CONVERGENCE: { code: 'slow', label: 'âš  åæŸé…å»¶', color: 'warning',
            desc: 'åæŸãŒéå¸¸ã«é…ã„ã§ã™ã€‚Newton-Raphsonæ³•ã¸ã®åˆ‡ã‚Šæ›¿ãˆã‚’æ¨å¥¨ã—ã¾ã™ã€‚' },
        MAX_ITER: { code: 'max_iter', label: 'âš  æœ€å¤§åå¾©', color: 'warning',
            desc: 'æœ€å¤§åå¾©å›æ•°ã«é”ã—ã¾ã—ãŸã€‚' },
        NUMERICAL_ISSUE: { code: 'numerical', label: 'âš  æ•°å€¤å•é¡Œ', color: 'warning',
            desc: 'æ•°å€¤ç²¾åº¦ã®å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚è¨±å®¹èª¤å·®ã‚’ç·©å’Œã™ã‚‹ã‹ã€ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚' },
        LOCAL_MINIMUM: { code: 'local_min', label: 'âš  å±€æ‰€è§£', color: 'warning',
            desc: 'å±€æ‰€çš„ãªæœ€å°ç‚¹ã«åæŸã—ãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åˆæœŸç‚¹ã‚’å¤‰æ›´ã—ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚' },
        DC_APPROXIMATION: { code: 'dc_approx', label: 'â„¹ DCè¿‘ä¼¼', color: 'info',
            desc: 'DCæ½®æµæ³•ã¯ç·šå½¢è¿‘ä¼¼ã§ã™ã€‚ACè§£ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚' }
    };

    function diagnoseConvergence() {
        const n = state.errorHistory.length;
        if (n < 2) return null;
        
        const currentError = state.errorHistory[n - 1];
        const prevError = state.errorHistory[n - 2];
        const tol = state.tolerance;
        
        // åæŸåˆ¤å®š
        if (currentError < tol) {
            return DIAGNOSIS.CONVERGED;
        }
        
        // DCæ³•ã¯ç‰¹åˆ¥æ‰±ã„
        if (state.algorithm === 'dc') {
            return DIAGNOSIS.DC_APPROXIMATION;
        }
        
        // ç™ºæ•£æ¤œå‡ºï¼ˆèª¤å·®ãŒ3å›é€£ç¶šã§å¢—åŠ ï¼‰
        if (n >= 3) {
            const e1 = state.errorHistory[n - 3];
            const e2 = state.errorHistory[n - 2];
            const e3 = state.errorHistory[n - 1];
            if (e3 > e2 * 1.5 && e2 > e1 * 1.5) {
                return DIAGNOSIS.DIVERGING;
            }
        }
        
        // æŒ¯å‹•æ¤œå‡ºï¼ˆèª¤å·®ãŒä¸Šä¸‹ã‚’ç¹°ã‚Šè¿”ã™ï¼‰
        if (n >= 4) {
            const errors = state.errorHistory.slice(-4);
            const diffs = [];
            for (let i = 1; i < errors.length; i++) {
                diffs.push(errors[i] - errors[i-1]);
            }
            // ç¬¦å·ãŒäº¤äº’ã«å¤‰ã‚ã‚‹ = æŒ¯å‹•
            let signChanges = 0;
            for (let i = 1; i < diffs.length; i++) {
                if (diffs[i] * diffs[i-1] < 0) signChanges++;
            }
            if (signChanges >= 2 && currentError < tol * 100) {
                return DIAGNOSIS.OSCILLATING;
            }
        }
        
        // åœæ»æ¤œå‡ºï¼ˆæ”¹å–„ç‡ãŒéå¸¸ã«å°ã•ã„ï¼‰
        if (n >= 5) {
            const recentErrors = state.errorHistory.slice(-5);
            const improvement = (recentErrors[0] - recentErrors[4]) / recentErrors[0];
            if (Math.abs(improvement) < 0.01) {
                // å±€æ‰€è§£ã‹åœæ»ã‹ã‚’åˆ¤æ–­
                if (currentError > tol * 10) {
                    return DIAGNOSIS.LOCAL_MINIMUM;
                } else {
                    return DIAGNOSIS.STUCK;
                }
            }
        }
        
        // åæŸé…å»¶æ¤œå‡ºï¼ˆç·šå½¢åæŸã®æ¤œå‡ºï¼‰
        if (n >= 10 && state.algorithm !== 'newton') {
            const e1 = state.errorHistory[n - 10];
            const e2 = state.errorHistory[n - 1];
            const avgReduction = Math.pow(e2 / e1, 1/9);
            if (avgReduction > 0.9 && currentError > tol * 10) {
                return DIAGNOSIS.SLOW_CONVERGENCE;
            }
        }
        
        // æ•°å€¤ç²¾åº¦å•é¡Œï¼ˆèª¤å·®ãŒè¨±å®¹å€¤ã«è¿‘ã„ãŒåæŸã—ãªã„ï¼‰
        if (currentError < tol * 10 && currentError > tol && n > 20) {
            return DIAGNOSIS.NUMERICAL_ISSUE;
        }
        
        // æœ€å¤§åå¾©åˆ°é”
        if (state.iteration >= state.maxIterations - 1) {
            return DIAGNOSIS.MAX_ITER;
        }
        
        return null;  // ç¶™ç¶šä¸­
    }

    function logDiagnosis(diagnosis) {
        if (!diagnosis) return;
        
        const prefix = diagnosis.label;
        const msg = diagnosis.desc;
        
        log(`\n========== è¨ºæ–­çµæœ ==========`, diagnosis.color);
        log(`${prefix}`, diagnosis.color);
        log(`${msg}`, diagnosis.color);
        
        // UIãƒ‘ãƒãƒ«ã«è¡¨ç¤º
        const panel = document.getElementById('diagnosisPanel');
        const title = document.getElementById('diagnosisTitle');
        const desc = document.getElementById('diagnosisDesc');
        const hint = document.getElementById('diagnosisHint');
        
        panel.style.display = 'block';
        title.textContent = diagnosis.label;
        desc.textContent = diagnosis.desc;
        
        // èƒŒæ™¯è‰²ã‚’è¨­å®š
        const colors = {
            success: 'rgba(81, 207, 102, 0.2)',
            warning: 'rgba(255, 169, 77, 0.2)',
            error: 'rgba(255, 107, 107, 0.2)',
            info: 'rgba(77, 171, 247, 0.2)'
        };
        panel.style.background = colors[diagnosis.color] || colors.info;
        
        // è¿½åŠ ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹
        let hintText = '';
        if (diagnosis.code === 'oscillating') {
            hintText = `ğŸ’¡ è¨±å®¹èª¤å·®ã‚’ç·©å’Œã—ã¦ã¿ã¦ãã ã•ã„ï¼ˆç¾åœ¨: ${state.tolerance.toExponential(1)}ï¼‰`;
            log(`ãƒ’ãƒ³ãƒˆ: è¨±å®¹èª¤å·®ã‚’ç·©å’Œï¼ˆç¾åœ¨: ${state.tolerance.toExponential(1)}ï¼‰`, 'warning');
        } else if (diagnosis.code === 'slow') {
            hintText = 'ğŸ’¡ Newton-Raphsonæ³•ã¯2æ¬¡åæŸã§é«˜é€Ÿã§ã™';
            log(`ãƒ’ãƒ³ãƒˆ: Newton-Raphsonæ³•ã¯2æ¬¡åæŸã§é«˜é€Ÿã§ã™`, 'warning');
        } else if (diagnosis.code === 'diverging') {
            hintText = `ğŸ’¡ åˆæœŸç‚¹ã‚’çœŸã®è§£ã«è¿‘ã¥ã‘ã¦ã¿ã¦ãã ã•ã„`;
            log(`ãƒ’ãƒ³ãƒˆ: åˆæœŸç‚¹ V=${state.trajectory[0]?.V.toFixed(3)}, Î´=${(state.trajectory[0]?.delta*180/Math.PI).toFixed(1)}Â° ã‹ã‚‰é–‹å§‹`, 'warning');
            if (state.trueSolution?.converged) {
                log(`å‚è€ƒ: çœŸã®è§£ã¯ V=${state.trueSolution.V.toFixed(4)}, Î´=${(state.trueSolution.delta*180/Math.PI).toFixed(2)}Â°`, 'success');
            }
        } else if (diagnosis.code === 'local_min') {
            hintText = 'ğŸ’¡ Newton-Raphsonæ³•ã¸ã®åˆ‡ã‚Šæ›¿ãˆã‚’æ¨å¥¨ã—ã¾ã™';
            log(`ãƒ’ãƒ³ãƒˆ: å‹¾é…é™ä¸‹æ³•ã¯å±€æ‰€è§£ã«é™¥ã‚Šã‚„ã™ã„ã§ã™ã€‚Newton-Raphsonæ³•ã‚’æ¨å¥¨ã€‚`, 'warning');
        } else if (diagnosis.code === 'stuck') {
            hintText = 'ğŸ’¡ åˆæœŸç‚¹ã‚’å¤‰æ›´ã™ã‚‹ã‹ã€åˆ¥ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è©¦ã—ã¦ãã ã•ã„';
        } else if (diagnosis.code === 'numerical') {
            hintText = `ğŸ’¡ è¨±å®¹èª¤å·®ã‚’ ${(state.tolerance * 10).toExponential(0)} ã«ç·©å’Œã—ã¦ã¿ã¦ãã ã•ã„`;
        } else if (diagnosis.code === 'converged') {
            hintText = `ğŸ‰ ${state.iteration}å›ã®åå¾©ã§åæŸã—ã¾ã—ãŸ`;
        }
        
        hint.textContent = hintText;
        
        log(`==============================\n`);
        
        state.diagnosisResult = diagnosis;
    }
    
    function hideDiagnosisPanel() {
        document.getElementById('diagnosisPanel').style.display = 'none';
    }

    // ================================================================
    // æ½®æµè¨ˆç®—ã‚³ã‚¢é–¢æ•°
    // ================================================================
    
    // P, Qè¨ˆç®— (å˜ä¸€ãƒã‚¹ã€ä»–ãƒã‚¹ã¯ãƒ•ãƒ©ãƒƒãƒˆæƒ³å®š)
    function calcPQ(prob, busIdx, V, delta) {
        const Ybus = prob.Ybus;
        const n = Ybus.length;
        let Pcalc = 0, Qcalc = 0;
        
        for (let j = 0; j < n; j++) {
            let Vj, deltaj;
            if (j === busIdx) {
                Vj = V; deltaj = delta;
            } else {
                Vj = prob.buses[j].V;
                deltaj = prob.buses[j].delta || 0;
            }
            const G = Ybus[busIdx][j].re;
            const B = Ybus[busIdx][j].im;
            const theta = delta - deltaj;
            Pcalc += V * Vj * (G * Math.cos(theta) + B * Math.sin(theta));
            Qcalc += V * Vj * (G * Math.sin(theta) - B * Math.cos(theta));
        }
        return { Pcalc, Qcalc };
    }

    // ãƒŸã‚¹ãƒãƒƒãƒè¨ˆç®—
    function calcMismatch(prob, busIdx, V, delta) {
        const { Pcalc, Qcalc } = calcPQ(prob, busIdx, V, delta);
        const bus = prob.buses[busIdx];
        return {
            deltaP: bus.Pspec - Pcalc,
            deltaQ: bus.Qspec - Qcalc
        };
    }

    // èª¤å·®ãƒãƒ«ãƒ 
    function calcError(prob, busIdx, V, delta) {
        const m = calcMismatch(prob, busIdx, V, delta);
        return Math.sqrt(m.deltaP * m.deltaP + m.deltaQ * m.deltaQ);
    }

    // Jacobianè¨ˆç®—ï¼ˆæ•°å€¤å¾®åˆ†ã§æ±ç”¨åŒ–ï¼‰
    function calcJacobian(prob, busIdx, V, delta) {
        const h = 1e-6;
        const m0 = calcMismatch(prob, busIdx, V, delta);
        
        // âˆ‚P/âˆ‚Î´, âˆ‚Q/âˆ‚Î´
        const m_d = calcMismatch(prob, busIdx, V, delta + h);
        const J11 = -(m_d.deltaP - m0.deltaP) / h;  // dP/dÎ´ (ãƒŸã‚¹ãƒãƒƒãƒã®å¾®åˆ†ãªã®ã§ç¬¦å·åè»¢)
        const J21 = -(m_d.deltaQ - m0.deltaQ) / h;  // dQ/dÎ´
        
        // âˆ‚P/âˆ‚V, âˆ‚Q/âˆ‚V
        const m_V = calcMismatch(prob, busIdx, V + h, delta);
        const J12 = -(m_V.deltaP - m0.deltaP) / h;  // dP/dV
        const J22 = -(m_V.deltaQ - m0.deltaQ) / h;  // dQ/dV
        
        return { J11, J12, J21, J22 };
    }

    // çœŸã®è§£ã‚’NRæ³•ã§è¨ˆç®—
    function computeTrueSolution(prob) {
        const busIdx = prob.solverBus;
        let V = 1.0, delta = 0.0;
        
        for (let iter = 0; iter < 50; iter++) {
            const m = calcMismatch(prob, busIdx, V, delta);
            const err = Math.sqrt(m.deltaP * m.deltaP + m.deltaQ * m.deltaQ);
            if (err < 1e-12) return { V, delta, converged: true, iterations: iter };
            
            const J = calcJacobian(prob, busIdx, V, delta);
            const det = J.J11 * J.J22 - J.J12 * J.J21;
            if (Math.abs(det) < 1e-15) break;
            
            delta += (J.J22 * m.deltaP - J.J12 * m.deltaQ) / det;
            V += (-J.J21 * m.deltaP + J.J11 * m.deltaQ) / det;
            V = Math.max(0.5, Math.min(1.3, V));
        }
        return { V, delta, converged: false, iterations: 50 };
    }

    // DCæ½®æµè¨ˆç®— (Qç„¡è¦–ã€V=1å›ºå®šã€ç·šå½¢è¿‘ä¼¼)
    // P â‰ˆ B * Î´ â†’ Î´ â‰ˆ P / B (Bã¯è² ãªã®ã§ç¬¦å·æ³¨æ„)
    function computeDCSolution(prob) {
        const busIdx = prob.solverBus;
        const B0 = prob.Ybus[busIdx][0].im;  // Slackã¨ã®ã‚µã‚»ãƒ—ã‚¿ãƒ³ã‚¹ï¼ˆæ­£ã®å€¤ã€ä¾‹: 30ï¼‰
        const Pspec = prob.buses[busIdx].Pspec;  // è² è·ã¯è² 
        // DCè¿‘ä¼¼: P = Vâ‚Vâ‚‚B sin(Î´) â‰ˆ B*Î´ (å°è§’åº¦è¿‘ä¼¼ã€V=1)
        // Î´ = P / B
        const delta = Pspec / B0;
        return { V: 1.0, delta };
    }

    // ================================================================
    // ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…
    // ================================================================
    
    function newtonStep() {
        const prob = problems[state.problem];
        const busIdx = prob.solverBus;
        const m = calcMismatch(prob, busIdx, state.V, state.delta);
        const J = calcJacobian(prob, busIdx, state.V, state.delta);
        const det = J.J11 * J.J22 - J.J12 * J.J21;
        
        if (Math.abs(det) < 1e-15) {
            log('Jacobianç‰¹ç•°! è¨ˆç®—åœæ­¢', 'error');
            return { error: Infinity, converged: false };
        }
        
        const dDelta = (J.J22 * m.deltaP - J.J12 * m.deltaQ) / det;
        const dV = (-J.J21 * m.deltaP + J.J11 * m.deltaQ) / det;
        
        state.delta += dDelta;
        state.V += dV;
        state.V = Math.max(0.5, Math.min(1.3, state.V));
        
        const error = calcError(prob, busIdx, state.V, state.delta);
        log(`NR[${state.iteration}]: V=${state.V.toFixed(5)}, Î´=${(state.delta*180/Math.PI).toFixed(3)}Â°, err=${error.toExponential(2)}`);
        
        return { error, converged: error < state.tolerance };
    }

    function gaussSeidelStep() {
        const prob = problems[state.problem];
        const busIdx = prob.solverBus;
        const Ybus = prob.Ybus;
        const bus = prob.buses[busIdx];
        
        const Yii = Ybus[busIdx][busIdx];
        
        // V_new = (1/Yii) * [S*/V* - Î£(jâ‰ i) Yij*Vj]
        const V_re = state.V * Math.cos(state.delta);
        const V_im = state.V * Math.sin(state.delta);
        const Vmag2 = state.V * state.V;
        
        // S* / V (S = P + jQ, S* = P - jQ)
        const Sconj_re = bus.Pspec, Sconj_im = -bus.Qspec;
        const SoV_re = (Sconj_re * V_re + Sconj_im * V_im) / Vmag2;
        const SoV_im = (Sconj_im * V_re - Sconj_re * V_im) / Vmag2;
        
        // Î£ Yij * Vj (j â‰  i)
        let sumYV_re = 0, sumYV_im = 0;
        for (let j = 0; j < Ybus.length; j++) {
            if (j === busIdx) continue;
            const Yij = Ybus[busIdx][j];
            const Vj = prob.buses[j].V;
            const dj = prob.buses[j].delta || 0;
            const Vj_re = Vj * Math.cos(dj);
            const Vj_im = Vj * Math.sin(dj);
            sumYV_re += Yij.re * Vj_re - Yij.im * Vj_im;
            sumYV_im += Yij.re * Vj_im + Yij.im * Vj_re;
        }
        
        const rhs_re = SoV_re - sumYV_re;
        const rhs_im = SoV_im - sumYV_im;
        
        // V_new = rhs / Yii
        const Yiimag2 = Yii.re * Yii.re + Yii.im * Yii.im;
        const Vnew_re = (rhs_re * Yii.re + rhs_im * Yii.im) / Yiimag2;
        const Vnew_im = (rhs_im * Yii.re - rhs_re * Yii.im) / Yiimag2;
        
        const newMag = Math.sqrt(Vnew_re * Vnew_re + Vnew_im * Vnew_im);
        const newAngle = Math.atan2(Vnew_im, Vnew_re);
        
        // é©å¿œç·©å’Œä¿‚æ•°
        const prevError = state.errorHistory.length > 0 ? 
            state.errorHistory[state.errorHistory.length - 1] : Infinity;
        const currentError = calcError(prob, busIdx, state.V, state.delta);
        
        // ç·©å’Œä¿‚æ•°ï¼ˆé›»åŠ›ç³»çµ±Yè¡Œåˆ—ã¯å¯¾è§’å„ªä½ã§ãªã„ãŸã‚å°ã•ã‚ã«ï¼‰
        let alpha = 0.5;
        if (currentError > prevError) alpha = 0.2;
        
        const oldV = state.V, oldDelta = state.delta;
        state.V = state.V + alpha * (newMag - state.V);
        state.delta = state.delta + alpha * (newAngle - state.delta);
        state.V = Math.max(0.5, Math.min(1.3, state.V));
        
        const error = calcError(prob, busIdx, state.V, state.delta);
        
        // åœæ»æ¤œå‡º
        if (Math.abs(error - prevError) < 1e-10 && state.iteration > 20) {
            log(`GS[${state.iteration}]: åœæ»æ¤œå‡º - GSæ³•ã¯ã“ã®ç³»çµ±ã§ã¯åæŸå›°é›£`, 'warning');
        } else {
            log(`GS[${state.iteration}]: V=${state.V.toFixed(5)}, Î´=${(state.delta*180/Math.PI).toFixed(3)}Â°, err=${error.toExponential(2)}`);
        }
        
        return { error, converged: error < state.tolerance };
    }

    function gradientStep() {
        const prob = problems[state.problem];
        const busIdx = prob.solverBus;
        const currentError = calcError(prob, busIdx, state.V, state.delta);
        
        // ä¸­å¿ƒå·®åˆ†ã§æ•°å€¤å‹¾é…ï¼ˆç›®çš„é–¢æ•° = errorÂ² ã®å‹¾é…ï¼‰
        const h = 1e-5;
        const err_dp = calcError(prob, busIdx, state.V, state.delta + h);
        const err_dm = calcError(prob, busIdx, state.V, state.delta - h);
        const err_Vp = calcError(prob, busIdx, state.V + h, state.delta);
        const err_Vm = calcError(prob, busIdx, state.V - h, state.delta);
        
        const grad_delta = (err_dp * err_dp - err_dm * err_dm) / (2 * h);
        const grad_V = (err_Vp * err_Vp - err_Vm * err_Vm) / (2 * h);
        
        const gradNorm = Math.sqrt(grad_delta * grad_delta + grad_V * grad_V);
        if (gradNorm < 1e-12) {
            log(`GD[${state.iteration}]: å‹¾é…ãŒã‚¼ãƒ­ - åœæ­¢`, 'warning');
            return { error: currentError, converged: currentError < state.tolerance };
        }
        
        // æ­£è¦åŒ–ã—ãŸé™ä¸‹æ–¹å‘
        const dir_delta = -grad_delta / gradNorm;
        const dir_V = -grad_V / gradNorm;
        
        // èª¤å·®ã«å¿œã˜ãŸåˆæœŸã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º
        let baseStep = Math.min(0.1, currentError * 0.5);
        baseStep = Math.max(baseStep, 1e-4);
        
        // ç·šæ¢ç´¢ã§æœ€è‰¯ç‚¹ã‚’æ¢ã™
        let bestV = state.V, bestDelta = state.delta, bestErr = currentError;
        for (let k = 0; k < 20; k++) {
            const alpha = baseStep * Math.pow(0.5, k);
            const newV = Math.max(0.5, Math.min(1.3, state.V + alpha * dir_V));
            const newDelta = state.delta + alpha * dir_delta;
            const newErr = calcError(prob, busIdx, newV, newDelta);
            
            if (newErr < bestErr) {
                bestErr = newErr;
                bestV = newV;
                bestDelta = newDelta;
            }
        }
        
        state.V = bestV;
        state.delta = bestDelta;
        
        log(`GD[${state.iteration}]: V=${state.V.toFixed(5)}, Î´=${(state.delta*180/Math.PI).toFixed(3)}Â°, err=${bestErr.toExponential(2)}`);
        
        return { error: bestErr, converged: bestErr < state.tolerance };
    }

    function dcStep() {
        // DCæ³•ã¯1å›ã§è§£ãŒå‡ºã‚‹ï¼ˆç·šå½¢è¿‘ä¼¼ï¼‰
        const dc = state.dcSolution;
        state.V = dc.V;
        state.delta = dc.delta;
        
        const prob = problems[state.problem];
        const error = calcError(prob, prob.solverBus, state.V, state.delta);
        
        log(`DCæ½®æµæ³•ã®çµæœ:`);
        log(`  V = ${state.V.toFixed(5)} (å›ºå®š), Î´ = ${(state.delta*180/Math.PI).toFixed(3)}Â°`);
        log(`  ACè§£ã¨ã®èª¤å·®: ${error.toExponential(2)}`);
        
        if (state.trueSolution && state.trueSolution.converged) {
            const dV = Math.abs(state.V - state.trueSolution.V);
            const dDelta = Math.abs(state.delta - state.trueSolution.delta) * 180 / Math.PI;
            log(`  çœŸã®è§£ã¨ã®å·®: Î”V=${dV.toFixed(4)}, Î”Î´=${dDelta.toFixed(2)}Â°`, 'warning');
        }
        
        return { error, converged: true };  // DCæ³•ã¯å¸¸ã«1å›ã§å®Œäº†
    }

    function doIteration() {
        switch (state.algorithm) {
            case 'newton': return newtonStep();
            case 'gauss-seidel': return gaussSeidelStep();
            case 'gradient': return gradientStep();
            case 'dc': return dcStep();
        }
    }

    // ================================================================
    // UIåˆ¶å¾¡
    // ================================================================
    
    function log(msg, type = '') {
        const el = document.getElementById('logOutput');
        const cls = type ? `log-${type}` : '';
        el.innerHTML += `<span class="${cls}">${msg}</span>\n`;
        el.scrollTop = el.scrollHeight;
    }

    function clearLog() {
        document.getElementById('logOutput').innerHTML = '';
    }

    function reset() {
        state.running = false;
        state.iteration = 0;
        
        const prob = problems[state.problem];
        state.V = prob.initialV;
        state.delta = prob.initialDelta;
        state.trajectory = [{ V: state.V, delta: state.delta }];
        state.errorHistory = [];
        
        // è¨ºæ–­çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
        state.stuckCount = 0;
        state.oscillationCount = 0;
        state.divergenceCount = 0;
        state.lastErrors = [];
        state.diagnosisResult = null;
        hideDiagnosisPanel();
        
        // çœŸã®è§£ã‚’è¨ˆç®—
        state.trueSolution = computeTrueSolution(prob);
        state.dcSolution = computeDCSolution(prob);
        
        clearLog();
        log(`=== ${prob.name} ===`);
        log(`åˆæœŸç‚¹: V=${state.V.toFixed(4)}, Î´=${(state.delta*180/Math.PI).toFixed(2)}Â°`);
        
        if (state.trueSolution.converged) {
            log(`çœŸã®è§£: V=${state.trueSolution.V.toFixed(5)}, Î´=${(state.trueSolution.delta*180/Math.PI).toFixed(3)}Â° (${state.trueSolution.iterations}å›ã§åæŸ)`, 'success');
        } else {
            log(`çœŸã®è§£: è¨ˆç®—å¤±æ•—`, 'error');
        }
        log(`DCè¿‘ä¼¼: V=1.0, Î´=${(state.dcSolution.delta*180/Math.PI).toFixed(3)}Â°`);
        log(`è¨±å®¹èª¤å·®: ${state.tolerance.toExponential(1)}`);
        log('---');
        
        updateDisplay();
        drawAll();
    }

    function updateDisplay() {
        document.getElementById('iterValue').textContent = state.iteration;
        document.getElementById('voltageValue').textContent = state.V.toFixed(4);
        document.getElementById('angleValue').textContent = (state.delta * 180 / Math.PI).toFixed(2) + 'Â°';
        
        if (state.errorHistory.length > 0) {
            document.getElementById('errorValue').textContent = state.errorHistory[state.errorHistory.length - 1].toExponential(2);
        }
        
        if (state.trueSolution && state.trueSolution.converged) {
            document.getElementById('trueVValue').textContent = state.trueSolution.V.toFixed(4);
            document.getElementById('trueDeltaValue').textContent = (state.trueSolution.delta * 180 / Math.PI).toFixed(2) + 'Â°';
        }
    }

    async function run() {
        if (state.running) return;
        state.running = true;
        state.diagnosisResult = null;
        document.getElementById('runBtn').disabled = true;
        
        let lastDiagnosis = null;
        
        while (state.running && state.iteration < state.maxIterations) {
            const result = doIteration();
            state.iteration++;
            state.trajectory.push({ V: state.V, delta: state.delta });
            state.errorHistory.push(result.error);
            
            updateDisplay();
            drawAll();
            
            // å®šæœŸçš„ã«è¨ºæ–­ã‚’å®Ÿè¡Œ
            if (state.iteration % 5 === 0 || result.converged) {
                const diagnosis = diagnoseConvergence();
                if (diagnosis && diagnosis !== lastDiagnosis) {
                    // é‡å¤§ãªå•é¡ŒãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰æ—©æœŸçµ‚äº†
                    if (diagnosis.code === 'diverging' || diagnosis.code === 'singular') {
                        logDiagnosis(diagnosis);
                        break;
                    }
                    lastDiagnosis = diagnosis;
                }
            }
            
            if (result.converged) {
                logDiagnosis(DIAGNOSIS.CONVERGED);
                break;
            }
            
            if (state.algorithm === 'dc') {
                logDiagnosis(DIAGNOSIS.DC_APPROXIMATION);
                break;
            }
            
            await new Promise(r => setTimeout(r, 300 / state.speed));
        }
        
        // æœ€çµ‚è¨ºæ–­
        if (!state.diagnosisResult) {
            const finalDiagnosis = diagnoseConvergence();
            if (finalDiagnosis) {
                logDiagnosis(finalDiagnosis);
            } else if (state.iteration >= state.maxIterations) {
                logDiagnosis(DIAGNOSIS.MAX_ITER);
            }
        }
        
        state.running = false;
        document.getElementById('runBtn').disabled = false;
    }

    async function step() {
        if (state.running) return;
        
        const result = doIteration();
        state.iteration++;
        state.trajectory.push({ V: state.V, delta: state.delta });
        state.errorHistory.push(result.error);
        
        updateDisplay();
        drawAll();
        
        if (result.converged) {
            logDiagnosis(DIAGNOSIS.CONVERGED);
        } else {
            // ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«è¨ºæ–­
            const diagnosis = diagnoseConvergence();
            if (diagnosis && diagnosis.code !== 'converged') {
                log(`[è¨ºæ–­] ${diagnosis.label}: ${diagnosis.desc}`, diagnosis.color);
            }
        }
    }

    // ================================================================
    // æç”»
    // ================================================================
    
    function getViewRange() {
        const prob = problems[state.problem];
        let allV = [state.trueSolution?.V || 1, state.dcSolution?.V || 1, prob.initialV];
        let allD = [state.trueSolution?.delta || 0, state.dcSolution?.delta || 0, prob.initialDelta];
        
        state.trajectory.forEach(p => { allV.push(p.V); allD.push(p.delta); });
        
        const Vmin = Math.min(...allV) - 0.1;
        const Vmax = Math.max(...allV) + 0.1;
        const dMin = Math.min(...allD) - 0.1;
        const dMax = Math.max(...allD) + 0.1;
        
        return { Vmin: Math.max(0.5, Vmin), Vmax: Math.min(1.4, Vmax), dMin, dMax };
    }

    function drawAll() {
        drawComplexPlane();
        drawErrorSurface();
        drawConvergenceChart();
        drawVectorField();
    }

    function drawComplexPlane() {
        const canvas = document.getElementById('complexPlane');
        const ctx = canvas.getContext('2d');
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width - 20;
        canvas.height = rect.height - 20;
        const w = canvas.width, h = canvas.height;
        const cx = w / 2, cy = h / 2;
        
        const range = getViewRange();
        const maxR = Math.max(range.Vmax, Math.abs(range.dMin), Math.abs(range.dMax)) * 1.2;
        const scale = Math.min(w, h) * 0.4 / maxR;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, w, h);

        // ã‚°ãƒªãƒƒãƒ‰
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        for (let r = 0.2; r <= maxR; r += 0.2) {
            ctx.beginPath();
            ctx.arc(cx, cy, r * scale, 0, 2 * Math.PI);
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.moveTo(0, cy); ctx.lineTo(w, cy);
        ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
        ctx.stroke();

        // DCè§£
        if (state.dcSolution) {
            const x = cx + state.dcSolution.V * Math.cos(state.dcSolution.delta) * scale;
            const y = cy - state.dcSolution.V * Math.sin(state.dcSolution.delta) * scale;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255,169,77,0.5)';
            ctx.fill();
            ctx.fillStyle = '#ffa94d';
            ctx.font = '10px sans-serif';
            ctx.fillText('DC', x + 10, y);
        }

        // çœŸã®è§£
        if (state.trueSolution && state.trueSolution.converged) {
            const x = cx + state.trueSolution.V * Math.cos(state.trueSolution.delta) * scale;
            const y = cy - state.trueSolution.V * Math.sin(state.trueSolution.delta) * scale;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(81,207,102,0.3)';
            ctx.fill();
            ctx.strokeStyle = '#51cf66';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#51cf66';
            ctx.font = '10px sans-serif';
            ctx.fillText('çœŸã®è§£', x + 12, y);
        }

        // è»Œè·¡
        if (state.trajectory.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = '#ffa94d';
            ctx.lineWidth = 2;
            state.trajectory.forEach((p, i) => {
                const x = cx + p.V * Math.cos(p.delta) * scale;
                const y = cy - p.V * Math.sin(p.delta) * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            state.trajectory.forEach((p, i) => {
                const x = cx + p.V * Math.cos(p.delta) * scale;
                const y = cy - p.V * Math.sin(p.delta) * scale;
                ctx.beginPath();
                ctx.arc(x, y, i === state.trajectory.length - 1 ? 6 : 3, 0, 2 * Math.PI);
                ctx.fillStyle = i === state.trajectory.length - 1 ? '#4dabf7' : '#ffa94d';
                ctx.fill();
            });
        }

        ctx.fillStyle = '#e9ecef';
        ctx.font = '11px sans-serif';
        ctx.fillText('Re(V)', w - 35, cy + 15);
        ctx.fillText('Im(V)', cx + 5, 15);
    }

    function drawErrorSurface() {
        const canvas = document.getElementById('errorSurface');
        const ctx = canvas.getContext('2d');
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width - 20;
        canvas.height = rect.height - 20;
        const w = canvas.width, h = canvas.height;

        const range = getViewRange();
        const prob = problems[state.problem];
        const busIdx = prob.solverBus;
        const res = 40;
        
        const errors = [];
        let maxErr = 0;
        for (let i = 0; i < res; i++) {
            errors[i] = [];
            for (let j = 0; j < res; j++) {
                const V = range.Vmin + (range.Vmax - range.Vmin) * i / res;
                const d = range.dMin + (range.dMax - range.dMin) * j / res;
                const err = calcError(prob, busIdx, V, d);
                errors[i][j] = err;
                maxErr = Math.max(maxErr, err);
            }
        }

        const cellW = w / res, cellH = h / res;
        for (let i = 0; i < res; i++) {
            for (let j = 0; j < res; j++) {
                const norm = Math.min(errors[i][j] / maxErr, 1);
                const hue = (1 - norm) * 240;
                ctx.fillStyle = `hsl(${hue}, 80%, ${30 + norm * 30}%)`;
                ctx.fillRect(j * cellW, (res - 1 - i) * cellH, cellW + 1, cellH + 1);
            }
        }

        // è»Œè·¡
        if (state.trajectory.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            state.trajectory.forEach((p, i) => {
                const x = (p.delta - range.dMin) / (range.dMax - range.dMin) * w;
                const y = (1 - (p.V - range.Vmin) / (range.Vmax - range.Vmin)) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            const last = state.trajectory[state.trajectory.length - 1];
            const lx = (last.delta - range.dMin) / (range.dMax - range.dMin) * w;
            const ly = (1 - (last.V - range.Vmin) / (range.Vmax - range.Vmin)) * h;
            ctx.beginPath();
            ctx.arc(lx, ly, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();
        }

        // çœŸã®è§£
        if (state.trueSolution && state.trueSolution.converged) {
            const sx = (state.trueSolution.delta - range.dMin) / (range.dMax - range.dMin) * w;
            const sy = (1 - (state.trueSolution.V - range.Vmin) / (range.Vmax - range.Vmin)) * h;
            ctx.beginPath();
            ctx.arc(sx, sy, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#51cf66';
            ctx.fill();
        }

        ctx.fillStyle = '#e9ecef';
        ctx.font = '11px sans-serif';
        ctx.fillText('Î´ â†’', w - 25, h - 5);
        ctx.fillText('|V| â†‘', 5, 12);
    }

    function drawConvergenceChart() {
        const canvas = document.getElementById('convergenceChart');
        const ctx = canvas.getContext('2d');
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width - 20;
        canvas.height = rect.height - 20;
        const w = canvas.width, h = canvas.height;
        const pad = { top: 20, right: 20, bottom: 30, left: 50 };
        const pw = w - pad.left - pad.right;
        const ph = h - pad.top - pad.bottom;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, w, h);

        if (state.errorHistory.length === 0) {
            ctx.fillStyle = '#868e96';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('å®Ÿè¡Œã™ã‚‹ã¨åæŸå±¥æ­´ãŒè¡¨ç¤ºã•ã‚Œã¾ã™', w / 2, h / 2);
            return;
        }

        const data = state.errorHistory;
        const logData = data.map(d => Math.log10(Math.max(d, 1e-15)));
        const minLog = Math.min(...logData, Math.log10(state.tolerance)) - 1;
        const maxLog = Math.max(...logData) + 0.5;
        const xScale = pw / Math.max(data.length, 10);

        // ã‚°ãƒªãƒƒãƒ‰
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        for (let i = 0; i <= 5; i++) {
            const y = pad.top + i * ph / 5;
            ctx.beginPath();
            ctx.moveTo(pad.left, y);
            ctx.lineTo(pad.left + pw, y);
            ctx.stroke();
        }

        // è¨±å®¹å€¤ãƒ©ã‚¤ãƒ³
        const tolY = pad.top + (maxLog - Math.log10(state.tolerance)) / (maxLog - minLog) * ph;
        ctx.strokeStyle = '#ff6b6b';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(pad.left, tolY);
        ctx.lineTo(pad.left + pw, tolY);
        ctx.stroke();
        ctx.setLineDash([]);

        // èª¤å·®æ›²ç·š
        ctx.beginPath();
        ctx.strokeStyle = '#4dabf7';
        ctx.lineWidth = 2;
        data.forEach((val, i) => {
            const x = pad.left + (i + 1) * xScale;
            const y = pad.top + (maxLog - Math.log10(Math.max(val, 1e-15))) / (maxLog - minLog) * ph;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // ç¾åœ¨ç‚¹
        if (data.length > 0) {
            const x = pad.left + data.length * xScale;
            const y = pad.top + (maxLog - Math.log10(Math.max(data[data.length - 1], 1e-15))) / (maxLog - minLog) * ph;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#4dabf7';
            ctx.fill();
        }

        // è»¸ãƒ©ãƒ™ãƒ«
        ctx.fillStyle = '#e9ecef';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('åå¾©å›æ•°', w / 2, h - 5);
        ctx.textAlign = 'right';
        for (let i = 0; i <= 4; i++) {
            const logVal = maxLog - i * (maxLog - minLog) / 4;
            const y = pad.top + i * ph / 4;
            ctx.fillText(logVal.toFixed(0), pad.left - 5, y + 4);
        }
        ctx.save();
        ctx.translate(12, pad.top + ph / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('logâ‚â‚€(èª¤å·®)', 0, 0);
        ctx.restore();
    }

    function drawVectorField() {
        const canvas = document.getElementById('vectorField');
        const ctx = canvas.getContext('2d');
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width - 20;
        canvas.height = rect.height - 20;
        const w = canvas.width, h = canvas.height;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, w, h);

        const range = getViewRange();
        const prob = problems[state.problem];
        const busIdx = prob.solverBus;
        const gridSize = 10;
        const cellW = w / gridSize, cellH = h / gridSize;

        for (let i = 1; i < gridSize; i++) {
            for (let j = 1; j < gridSize; j++) {
                const V = range.Vmin + (range.Vmax - range.Vmin) * i / gridSize;
                const d = range.dMin + (range.dMax - range.dMin) * j / gridSize;
                const m = calcMismatch(prob, busIdx, V, d);
                const mag = Math.sqrt(m.deltaP * m.deltaP + m.deltaQ * m.deltaQ);
                if (mag < 0.001) continue;

                const scale = Math.min(mag * 30, 12);
                const dx = m.deltaP / mag * scale;
                const dy = -m.deltaQ / mag * scale;
                const cx = j * cellW, cy = (gridSize - i) * cellH;

                const hue = (1 - Math.min(mag, 1)) * 120;
                ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + dx * 2, cy + dy * 2);
                ctx.stroke();
            }
        }

        // è»Œè·¡
        if (state.trajectory.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = '#4dabf7';
            ctx.lineWidth = 2;
            state.trajectory.forEach((p, i) => {
                const x = (p.delta - range.dMin) / (range.dMax - range.dMin) * w;
                const y = (1 - (p.V - range.Vmin) / (range.Vmax - range.Vmin)) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        // çœŸã®è§£
        if (state.trueSolution && state.trueSolution.converged) {
            const sx = (state.trueSolution.delta - range.dMin) / (range.dMax - range.dMin) * w;
            const sy = (1 - (state.trueSolution.V - range.Vmin) / (range.Vmax - range.Vmin)) * h;
            ctx.beginPath();
            ctx.arc(sx, sy, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#51cf66';
            ctx.fill();
        }

        ctx.fillStyle = '#e9ecef';
        ctx.font = '11px sans-serif';
        ctx.fillText('Î´ â†’', w - 25, h - 5);
        ctx.fillText('|V| â†‘', 5, 12);
    }

    // ================================================================
    // åˆæœŸåŒ–
    // ================================================================
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('algoSelect').addEventListener('change', e => {
            state.algorithm = e.target.value;
            reset();
        });
        document.getElementById('problemSelect').addEventListener('change', e => {
            state.problem = e.target.value;
            reset();
        });
        document.getElementById('toleranceInput').addEventListener('change', e => {
            state.tolerance = parseFloat(e.target.value);
            reset();
        });
        document.getElementById('speedSlider').addEventListener('input', e => {
            state.speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = state.speed.toFixed(1) + 'x';
        });
        document.getElementById('runBtn').addEventListener('click', run);
        document.getElementById('stepBtn').addEventListener('click', step);
        document.getElementById('resetBtn').addEventListener('click', reset);

        reset();
    });

    window.addEventListener('resize', drawAll);
    </script>
</body>
</html>
